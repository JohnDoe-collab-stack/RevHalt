/-
  RevHalt.Dynamics.Operative.PNP

  FULLY INTERNAL (OPERATIVE) P / NP / coNP FOR RevHalt

  This file defines complexity classes purely from RevHalt primitives.
  ALL traces are LR-coded (no oracles disguised as arbitrary traces).
  ALL witnesses are finitarily bounded (List Bool).
  ALL reductions are operatively computable (via LR-coded map-problems).
  ALL contexts Γ are finitarily bounded (Finset with poly cardinality).

  A "problem" is an RHProblem: a VerifiableContext + LR-coded trace family.
  An instance `x` is a YES-instance iff `Halts (LR ctx (Γ x) (φ x))`.

  The only "resource" is the trace index `t : ℕ` (time / fuel).

  Provided notions:
  - `RHProblem` : LR-coded decision problem (with poly-bounded context)
  - `NatProblem` : ℕ-indexed with size = id (no cheating)
  - `Witness` : List Bool (finitarily standard)
  - `P_RH` / `NP_RH` / `coNP_RH` : internal complexity classes
  - `≤ₚ` : operative many-one poly reduction (via LR-coded map with size bound)
  - `P_ne_NP_RH`, `P_eq_NP_RH`, `NP_eq_coNP_RH` : internal statements
-/
import RevHalt.Kinetic.MasterClosure
import RevHalt.Kinetic.Closure
import Mathlib.Data.Nat.Basic
import Mathlib.Data.List.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Finset.Card
import Mathlib.Algebra.Order.Ring.Pow

namespace RevHalt.Dynamics.Operative.P_NP.PNP

open RevHalt

/-! ### §1. Polynomial Bounds -/

/-- A coarse internal notion of "polynomial bound" on a function `f : ℕ → ℕ`.

`IsPoly f` means: there exist constants `c,k` such that
`f n ≤ c * (n+1)^k + c` for all `n`.

This is intentionally permissive: it is a *bound schema* used to parameterize
"poly-time" in the operative setting.
-/
def IsPoly (f : ℕ → ℕ) : Prop :=
  ∃ (c k : ℕ), ∀ n : ℕ, f n ≤ c * (n + 1) ^ k + c

theorem IsPoly.const (c : ℕ) : IsPoly (fun _ => c) := by
  refine ⟨c, 0, ?_⟩
  intro n
  simp

theorem IsPoly.id_succ : IsPoly (fun n => n + 1) := by
  refine ⟨1, 1, ?_⟩
  intro n
  simp

theorem IsPoly.id : IsPoly (fun n => n) := by
  refine ⟨1, 1, ?_⟩
  intro n
  simp
  omega




/-! ### §1b. Monotone Hull for Polynomial Bounds -/

/-- Monotone hull of a bound function (primitive recursion).
This wraps any function to make it monotone while preserving IsPoly. -/
def monoHull (f : ℕ → ℕ) : ℕ → ℕ
  | 0     => f 0
  | n + 1 => Nat.max (monoHull f n) (f (n + 1))

theorem le_monoHull (f : ℕ → ℕ) : ∀ n, f n ≤ monoHull f n := by
  intro n
  induction n with
  | zero => exact le_refl _
  | succ n _ => exact Nat.le_max_right _ _

theorem monoHull_step (f : ℕ → ℕ) (n : ℕ) : monoHull f n ≤ monoHull f (n+1) := by
  exact Nat.le_max_left _ _

theorem monoHull_mono (f : ℕ → ℕ) : Monotone (monoHull f) := by
  intro a b hab
  induction hab with
  | refl => exact le_rfl
  | step _ ih => exact le_trans ih (monoHull_step f _)

private theorem polyBound_mono (c k : ℕ) :
    Monotone (fun n => c * (n + 1) ^ k + c) := by
  intro a b hab
  have h1 : a + 1 ≤ b + 1 := Nat.add_le_add_right hab 1
  have hpow : (a + 1) ^ k ≤ (b + 1) ^ k := Nat.pow_le_pow_left h1 k
  have hm : c * (a + 1) ^ k ≤ c * (b + 1) ^ k :=
    Nat.mul_le_mul_left c hpow
  exact Nat.add_le_add_right hm c

theorem isPoly_monoHull {g : ℕ → ℕ} (hg : IsPoly g) : IsPoly (monoHull g) := by
  obtain ⟨c, k, hgBound⟩ := hg
  refine ⟨c, k, ?_⟩
  let B : ℕ → ℕ := fun n => c * (n + 1) ^ k + c
  have hBmono : Monotone B := polyBound_mono c k
  intro n
  refine Nat.recOn n ?_ ?_
  · exact hgBound 0
  · intro m ih
    have h1 : monoHull g m ≤ B (m + 1) :=
      le_trans ih (hBmono (Nat.le_succ m))
    have h2 : g (m + 1) ≤ B (m + 1) := hgBound (m + 1)
    exact Nat.max_le.2 ⟨h1, h2⟩

/-! ### §2. Bounded Halting -/

/-- A bounded halting predicate: `tr` halts by time `T`. -/
def HaltsBy (tr : Trace) (T : ℕ) : Prop := ∃ t, t ≤ T ∧ tr t

theorem HaltsBy.halts {tr : Trace} {T : ℕ} : HaltsBy tr T → Halts tr := by
  intro ⟨t, _, ht⟩
  exact ⟨t, ht⟩

/-! ### §3. Finitarly Standard Witness Type -/

/-- The canonical witness type: a finite bitstring.
No arbitrary types allowed — this prevents infinite hidden information. -/
abbrev Witness := List Bool

/-- Witness size is list length. -/
def witnessSize : Witness → ℕ := List.length

/-! ### §4. RHProblem (LR-coded problems with poly-bounded context) -/

/-- An LR-coded decision problem with finitarily bounded context.

All traces are generated by `LR ctx (Γ x) (φ x)` — no arbitrary trace functions allowed.
The context `Γ x` is a **Finset** with cardinality polynomially bounded in `size x`.
This prevents hiding oracles in the context.
-/
structure RHProblem (ι : Type) where
  /-- Code type for the underlying VerifiableContext -/
  Code : Type
  /-- Proposition type for the underlying VerifiableContext -/
  PropT : Type
  /-- The verifiable context providing LR -/
  ctx : VerifiableContext Code PropT
  /-- Size function for inputs -/
  size : ι → ℕ
  /-- Context (hypotheses) for each input — FINSET, not Set! -/
  Γ : ι → Finset PropT
  /-- Goal proposition for each input -/
  φ : ι → PropT
  /-- Context cardinality bound function -/
  Γ_bound : ℕ → ℕ
  /-- Context bound is polynomial -/
  poly_Γ_bound : IsPoly Γ_bound
  /-- Context cardinality is bounded by Γ_bound (size x) -/
  Γ_ok : ∀ x, (Γ x).card ≤ Γ_bound (size x)

namespace RHProblem

variable {ι : Type}

/-- The trace for input x, generated by LR (canonical form). -/
def tr (P : RHProblem ι) (x : ι) : Trace := P.ctx.LR (↑(P.Γ x) : Set P.PropT) (P.φ x)

end RHProblem

/-- YES-instances: the LR-generated trace halts. -/
def Solves {ι : Type} (P : RHProblem ι) (x : ι) : Prop := Halts (P.tr x)

/-! ### §5. NatProblem (size = id, no cheating) -/

/-- A NatProblem is an ℕ-indexed problem with size FORCED to identity.
This prevents cheating by setting size = 0 to make everything "poly-time". -/
def NatProblem := { P : RHProblem ℕ // P.size = id }

namespace NatProblem

/-- Extract the underlying RHProblem. -/
def toProblem (P : NatProblem) : RHProblem ℕ := P.val

/-- Size is identity (enforced by subtype). -/
theorem size_eq_id (P : NatProblem) : P.val.size = id := P.property

end NatProblem

/-! ### §6. Class P_RH (Poly-time Deciders) -/

/-- A poly-time **total** operative decider.

Both `yes` and `no` traces are LR-coded in the *same* context as the problem.
Contexts are Finsets with poly-bounded cardinality.
Totality: either yes-trace halts within the bound, or no-trace halts within the bound.
Correctness: halting of yes/no matches Solves/¬Solves.
-/
structure PolyDecider {ι : Type} (P : RHProblem ι) where
  /-- Context for YES-verification -/
  yesΓ : ι → Finset P.PropT
  /-- Goal for YES-verification -/
  yesφ : ι → P.PropT
  /-- Context for NO-verification -/
  noΓ : ι → Finset P.PropT
  /-- Goal for NO-verification -/
  noφ : ι → P.PropT
  /-- Time bound function -/
  time : ℕ → ℕ
  /-- Context bound function -/
  ctx_bound : ℕ → ℕ
  /-- Time bound is polynomial -/
  poly_time : IsPoly time
  /-- Context bound is polynomial -/
  poly_ctx_bound : IsPoly ctx_bound
  /-- Context cardinality is bounded -/
  yes_ctx_ok : ∀ x, (yesΓ x).card ≤ ctx_bound (P.size x)
  no_ctx_ok : ∀ x, (noΓ x).card ≤ ctx_bound (P.size x)
  /-- Totality: one of yes/no halts in time -/
  total : ∀ x,
    HaltsBy (P.ctx.LR (↑(yesΓ x)) (yesφ x)) (time (P.size x)) ∨
    HaltsBy (P.ctx.LR (↑(noΓ x)) (noφ x)) (time (P.size x))
  /-- Soundness: yes halting implies YES-instance -/
  sound_yes : ∀ x, Halts (P.ctx.LR (↑(yesΓ x)) (yesφ x)) → Solves P x
  /-- Soundness: no halting implies NO-instance -/
  sound_no : ∀ x, Halts (P.ctx.LR (↑(noΓ x)) (noφ x)) → ¬ Solves P x
  /-- Completeness: YES-instance implies yes halts -/
  complete_yes : ∀ x, Solves P x → Halts (P.ctx.LR (↑(yesΓ x)) (yesφ x))
  /-- Completeness: NO-instance implies no halts -/
  complete_no : ∀ x, ¬ Solves P x → Halts (P.ctx.LR (↑(noΓ x)) (noφ x))

/-- `P_RH P` : there exists a poly-time total LR-decider for `P`. -/
def P_RH {ι : Type} (P : RHProblem ι) : Prop :=
  ∃ _ : PolyDecider P, True

/-! ### §7. Class NP_RH (Poly-time Verifiers with Finitarly Witnesses) -/

/-- A poly-time verifier with polynomial witness-size bound.

The verifier trace is LR-coded in the *same* context as the problem.
Witnesses are `List Bool` with size = length (finitarily standard).
Verification contexts are Finsets with poly-bounded cardinality.
A YES-instance `x` has a witness `w` of size bounded by `wBound (size x)` such that
the verifier trace halts within `time (size x)`.
-/
structure PolyVerifier {ι : Type} (P : RHProblem ι) where
  /-- Context for verification (depends on input and witness) -/
  VΓ : ι → Witness → Finset P.PropT
  /-- Goal for verification (depends on input and witness) -/
  Vφ : ι → Witness → P.PropT
  /-- Time bound function -/
  time : ℕ → ℕ
  /-- Witness size bound function -/
  wBound : ℕ → ℕ
  /-- Context bound function -/
  ctx_bound : ℕ → ℕ
  /-- Time bound is polynomial -/
  poly_time : IsPoly time
  /-- Witness bound is polynomial -/
  poly_wBound : IsPoly wBound
  /-- Context bound is polynomial -/
  poly_ctx_bound : IsPoly ctx_bound
  /-- Context cardinality is bounded -/
  ctx_ok : ∀ x w, (VΓ x w).card ≤ ctx_bound (P.size x + witnessSize w)
  /-- Correctness: Solves ↔ ∃ small witness with fast-halting verification -/
  correct : ∀ x,
    Solves P x ↔
    ∃ w : Witness, witnessSize w ≤ wBound (P.size x) ∧
         HaltsBy (P.ctx.LR (↑(VΓ x w)) (Vφ x w)) (time (P.size x))

/-- `NP_RH P` : there exists a poly-time LR-verifier for YES-instances of `P`. -/
def NP_RH {ι : Type} (P : RHProblem ι) : Prop :=
  ∃ _ : PolyVerifier P, True

/-! ### §8. Class coNP_RH (Poly-time Co-Verifiers with Finitarly Witnesses) -/

/-- A poly-time co-verifier for NO-instances.

The verifier trace is LR-coded in the *same* context as the problem.
Witnesses are `List Bool` with size = length (finitarily standard).
Verification contexts are Finsets with poly-bounded cardinality.
A NO-instance `x` has a witness `w` of size bounded by `wBound (size x)` such that
the verifier trace halts within `time (size x)`.
-/
structure PolyCoVerifier {ι : Type} (P : RHProblem ι) where
  /-- Context for NO-verification (depends on input and witness) -/
  VΓ : ι → Witness → Finset P.PropT
  /-- Goal for NO-verification (depends on input and witness) -/
  Vφ : ι → Witness → P.PropT
  /-- Time bound function -/
  time : ℕ → ℕ
  /-- Witness size bound function -/
  wBound : ℕ → ℕ
  /-- Context bound function -/
  ctx_bound : ℕ → ℕ
  /-- Time bound is polynomial -/
  poly_time : IsPoly time
  /-- Witness bound is polynomial -/
  poly_wBound : IsPoly wBound
  /-- Context bound is polynomial -/
  poly_ctx_bound : IsPoly ctx_bound
  /-- Context cardinality is bounded -/
  ctx_ok : ∀ x w, (VΓ x w).card ≤ ctx_bound (P.size x + witnessSize w)
  /-- Correctness: ¬Solves ↔ ∃ small witness with fast-halting verification -/
  correct : ∀ x,
    (¬ Solves P x) ↔
    ∃ w : Witness, witnessSize w ≤ wBound (P.size x) ∧
         HaltsBy (P.ctx.LR (↑(VΓ x w)) (Vφ x w)) (time (P.size x))

/-- `coNP_RH P` : there exists a poly-time LR-verifier for NO-instances of `P`. -/
def coNP_RH {ι : Type} (P : RHProblem ι) : Prop :=
  ∃ _ : PolyCoVerifier P, True

/-! ### §9. Operative Many-One Reductions (via LR-coded Map Problem with Size Bound) -/

/-- Internal operative many-one polynomial reduction.

The reduction is NOT a bare function `f : ι → κ` (which could be an oracle).
Instead, the reduction is witnessed by an **LR-coded map problem** that
operatively computes the mapping `y = f(x)`.

The map problem `map : RHProblem (ι × κ)` satisfies:
- It is in P_RH (total decidable in poly-time)
- It is total: for every x, there exists a y such that map(x,y) is a YES-instance
- It is functional: the y is unique
- **map.size is bounded** in terms of P.size and Q.size (no oracle via size)
- Size overhead is polynomial
- Correctness: Solves P x ↔ ∃ y with Solves map (x,y) ∧ Solves Q y
-/
structure PolyManyOneReduction {ι κ : Type} (P : RHProblem ι) (Q : RHProblem κ) where
  /-- The operative map relation (LR-coded) -/
  map : RHProblem (ι × κ)
  /-- The map is P_RH (operatively total decidable) -/
  map_in_P : P_RH map
  /-- Totality: for every x, there exists some y such that map(x,y) is YES -/
  total : ∀ x, ∃ y, Solves map (x, y)
  /-- Functionality: the y is unique -/
  functional : ∀ x y y', Solves map (x, y) → Solves map (x, y') → y = y'
  /-- Map size bound function -/
  map_sizeBound : ℕ → ℕ
  /-- Map size bound is polynomial -/
  poly_map_sizeBound : IsPoly map_sizeBound
  /-- Map size is bounded by P.size + Q.size (prevents oracle via size) -/
  map_size_ok : ∀ x y, map.size (x, y) ≤ map_sizeBound (P.size x + Q.size y)
  /-- Output size overhead bound -/
  sizeBound : ℕ → ℕ
  /-- Output size bound is polynomial -/
  poly_sizeBound : IsPoly sizeBound
  /-- Output size growth is bounded -/
  size_ok : ∀ x y, Solves map (x, y) → Q.size y ≤ sizeBound (P.size x)
  /-- Correctness: membership equivalence via the operative map -/
  correct : ∀ x, Solves P x ↔ ∃ y, Solves map (x, y) ∧ Solves Q y

/-- Notation for operative many-one poly reductions. -/
notation:50 P " ≤ₚ " Q => ∃ _ : PolyManyOneReduction P Q, True

/-! ### §10. Internal Complexity Statements -/

/-- The internal statement "P ≠ NP" in the operative sense:
there exists a NatProblem in `NP_RH` that is not in `P_RH`.

This is an *internal* proposition in the RevHalt universe; no external ontology is assumed.
-/
def P_ne_NP_RH : Prop :=
  ∃ (P : NatProblem), NP_RH P.val ∧ ¬ P_RH P.val

/-- The internal statement "P = NP":
every NatProblem in `NP_RH` is also in `P_RH`.
-/
def P_eq_NP_RH : Prop :=
  ∀ (P : NatProblem), NP_RH P.val → P_RH P.val

/-- The internal statement "NP = coNP":
every NatProblem is in `NP_RH` iff it is in `coNP_RH`.
-/
def NP_eq_coNP_RH : Prop :=
  ∀ (P : NatProblem), NP_RH P.val ↔ coNP_RH P.val

/-! ### §11. Basic Structural Theorems -/

/-- P ⊆ NP: every P_RH problem is also NP_RH.

The verifier ignores the witness and uses the decider's yes-trace.
-/
theorem P_subset_NP {ι : Type} (P : RHProblem ι) : P_RH P → NP_RH P := by
  intro ⟨D, _⟩
  -- Build verifier: VΓ x w := D.yesΓ x (ignore witness)
  -- Use a constant ctx_bound that ignores witness contribution
  refine ⟨{
    VΓ := fun x _ => D.yesΓ x
    Vφ := fun x _ => D.yesφ x
    time := D.time
    wBound := fun _ => 0
    -- ctx_bound wrapped in monoHull for monotonicity
    ctx_bound := monoHull D.ctx_bound
    poly_time := D.poly_time
    poly_wBound := IsPoly.const 0
    poly_ctx_bound := isPoly_monoHull D.poly_ctx_bound
    ctx_ok := fun x w => by
      have h0 : (D.yesΓ x).card ≤ D.ctx_bound (P.size x) := D.yes_ctx_ok x
      have h1 : D.ctx_bound (P.size x) ≤ monoHull D.ctx_bound (P.size x) :=
        le_monoHull D.ctx_bound (P.size x)
      have h2 : monoHull D.ctx_bound (P.size x) ≤
                monoHull D.ctx_bound (P.size x + witnessSize w) :=
        (monoHull_mono D.ctx_bound) (Nat.le_add_right _ _)
      exact le_trans h0 (le_trans h1 h2)
    correct := fun x => ⟨
      fun hS => ⟨[], by simp [witnessSize], by
        rcases D.total x with hY | hN
        · exact hY
        · exfalso; exact D.sound_no x hN.halts hS
      ⟩,
      fun ⟨_, _, hV⟩ => D.sound_yes x hV.halts
    ⟩
  }, trivial⟩

/-- P ⊆ coNP: every P_RH problem is also coNP_RH.

The co-verifier ignores the witness and uses the decider's no-trace.
-/
theorem P_subset_coNP {ι : Type} (P : RHProblem ι) : P_RH P → coNP_RH P := by
  intro ⟨D, _⟩
  refine ⟨{
    VΓ := fun x _ => D.noΓ x
    Vφ := fun x _ => D.noφ x
    time := D.time
    wBound := fun _ => 0
    ctx_bound := monoHull D.ctx_bound
    poly_time := D.poly_time
    poly_wBound := IsPoly.const 0
    poly_ctx_bound := isPoly_monoHull D.poly_ctx_bound
    ctx_ok := fun x w => by
      have h0 : (D.noΓ x).card ≤ D.ctx_bound (P.size x) := D.no_ctx_ok x
      have h1 : D.ctx_bound (P.size x) ≤ monoHull D.ctx_bound (P.size x) :=
        le_monoHull D.ctx_bound (P.size x)
      have h2 : monoHull D.ctx_bound (P.size x) ≤
                monoHull D.ctx_bound (P.size x + witnessSize w) :=
        (monoHull_mono D.ctx_bound) (Nat.le_add_right _ _)
      exact le_trans h0 (le_trans h1 h2)
    correct := fun x => ⟨
      fun hNS => ⟨[], by simp [witnessSize], by
        rcases D.total x with hY | hN
        · exfalso; exact hNS (D.sound_yes x hY.halts)
        · exact hN
      ⟩,
      fun ⟨_, _, hV⟩ => D.sound_no x hV.halts
    ⟩
  }, trivial⟩

/-! ### §12. SAT Module (NP-Complete Candidate) -/

namespace SAT

/-- Variables are naturals. -/
abbrev Var : Type := ℕ

/-- Literal = (variable, polarity). `neg = true` means ¬x_v. -/
structure Lit where
  v   : Var
  neg : Bool
  deriving DecidableEq

/-- Clause = disjunction of literals. -/
abbrev Clause : Type := List Lit

/-- CNF = conjunction of clauses. -/
abbrev CNF : Type := List Clause

/-- A coarse syntactic size for CNF formulas. -/
def cnfSize (F : CNF) : ℕ := F.length

/--
LR-coded SAT problem in an arbitrary `VerifiableContext`.

You provide:
- `Γsat F : Finset PropT`  (finite context that "describes" the instance)
- `φsat F : PropT`         (goal sentence: "F is satisfiable")
- a polynomial bound on `Γsat`'s cardinality.
-/
def SAT_RHProblem
    {Code PropT : Type}
    (ctx : VerifiableContext Code PropT)
    (Γsat : CNF → Finset PropT)
    (φsat : CNF → PropT)
    (Γ_bound : ℕ → ℕ)
    (poly_Γ_bound : IsPoly Γ_bound)
    (Γ_ok : ∀ F, (Γsat F).card ≤ Γ_bound (cnfSize F))
    : RHProblem CNF :=
{ Code := Code
  PropT := PropT
  ctx := ctx
  size := cnfSize
  Γ := Γsat
  φ := φsat
  Γ_bound := Γ_bound
  poly_Γ_bound := poly_Γ_bound
  Γ_ok := Γ_ok }

/--
Signature for an NP-verifier for SAT with locked witness type (List Bool).
-/
structure SATVerifierSig {Code PropT : Type} (ctx : VerifiableContext Code PropT) where
  VΓ        : CNF → Witness → Finset PropT
  Vφ        : CNF → Witness → PropT
  time      : ℕ → ℕ
  wBound    : ℕ → ℕ
  ctx_bound : ℕ → ℕ
  poly_time      : IsPoly time
  poly_wBound    : IsPoly wBound
  poly_ctx_bound : IsPoly ctx_bound
  ctx_ok : ∀ F w, (VΓ F w).card ≤ ctx_bound (cnfSize F + witnessSize w)

/--
Package minimal pour présenter SAT comme un `NatProblem` (indexé par ℕ, taille = id).

Idée : `n : ℕ` code une instance CNF via `decode n`.
On ne fixe pas ici l'encodage concret : c'est juste la **signature**.
-/
structure SATNatData {Code PropT : Type} (ctx : VerifiableContext Code PropT) where
  decode : ℕ → CNF
  Γsat   : CNF → Finset PropT
  φsat   : CNF → PropT
  Γ_boundNat      : ℕ → ℕ
  poly_Γ_boundNat : IsPoly Γ_boundNat
  Γ_okNat : ∀ n, (Γsat (decode n)).card ≤ Γ_boundNat n

/-- SAT vu comme `NatProblem` (size forcée à `id`). -/
def SAT_NatProblem {Code PropT : Type} (ctx : VerifiableContext Code PropT)
    (D : SATNatData (ctx := ctx)) : NatProblem :=
  ⟨{ Code := Code
     PropT := PropT
     ctx := ctx
     size := id
     Γ := fun n => D.Γsat (D.decode n)
     φ := fun n => D.φsat (D.decode n)
     Γ_bound := D.Γ_boundNat
     poly_Γ_bound := D.poly_Γ_boundNat
     Γ_ok := D.Γ_okNat
   }, rfl⟩

/-- "SAT ∈ NP_RH" (interne, au niveau NatProblem). -/
def SAT_in_NP {Code PropT : Type} (ctx : VerifiableContext Code PropT)
    (D : SATNatData (ctx := ctx)) : Prop :=
  NP_RH (SAT_NatProblem ctx D).val

/-- "SAT ∈ P_RH" (interne, au niveau NatProblem). -/
def SAT_in_P {Code PropT : Type} (ctx : VerifiableContext Code PropT)
    (D : SATNatData (ctx := ctx)) : Prop :=
  P_RH (SAT_NatProblem ctx D).val

/-- Réduction (NatProblem → SAT). -/
def ReducesToSAT_Nat (P : NatProblem) {Code PropT : Type} (ctx : VerifiableContext Code PropT)
    (D : SATNatData (ctx := ctx)) : Prop :=
  P.val ≤ₚ (SAT_NatProblem ctx D).val

/--
Énoncé "SAT est NP-complet" dans ton univers interne (version NatProblem).

- membership : SAT ∈ NP_RH
- complétude : tout NatProblem en NP_RH se réduit à SAT via `≤ₚ`
-/
def SAT_NPComplete {Code PropT : Type} (ctx : VerifiableContext Code PropT)
    (D : SATNatData (ctx := ctx)) : Prop :=
  SAT_in_NP ctx D ∧
  ∀ (P : NatProblem), NP_RH P.val → ReducesToSAT_Nat P ctx D

end SAT

/-! ### §13. Reduction Builders -/

/--
Builder for the LR-coded map-problem used in operative many-one reductions.
-/
def MapProblem
    {ι κ : Type}
    {Code PropT : Type}
    (ctx : VerifiableContext Code PropT)
    (size : ι × κ → ℕ)
    (Γmap : ι × κ → Finset PropT)
    (φmap : ι × κ → PropT)
    (Γ_bound : ℕ → ℕ)
    (poly_Γ_bound : IsPoly Γ_bound)
    (Γ_ok : ∀ z, (Γmap z).card ≤ Γ_bound (size z))
    : RHProblem (ι × κ) :=
{ Code := Code
  PropT := PropT
  ctx := ctx
  size := size
  Γ := Γmap
  φ := φmap
  Γ_bound := Γ_bound
  poly_Γ_bound := poly_Γ_bound
  Γ_ok := Γ_ok }

/--
Specialized type alias for reductions to SAT.
-/
def ReducesToSAT {ι : Type} (P : RHProblem ι) (SATP : RHProblem SAT.CNF) : Prop :=
  ∃ _ : PolyManyOneReduction P SATP, True

end RevHalt.Dynamics.Operative.P_NP.PNP
