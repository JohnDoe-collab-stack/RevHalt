/-
  RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas

  Stage A: Pure SAT semantics of genTableauAll.
  This file proves that the CNF generated by `genTableauAll` is satisfiable
  if and only if there exists a valid TableauRun.
-/
import RevHalt.Dynamics.Operative.P_NP.CookLevinTableau
import RevHalt.Dynamics.Operative.P_NP.CookLevinGadgets
import RevHalt.Dynamics.Operative.P_NP.SAT
import RevHalt.Dynamics.Operative.P_NP.PNP
import Mathlib.Data.List.Range
import Mathlib.Tactic.Linarith

namespace RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas

open RevHalt
open RevHalt.Dynamics.Operative.P_NP.SAT
open RevHalt.Dynamics.Operative.P_NP.SAT.CNF
open RevHalt.Dynamics.Operative.P_NP.CookLevinGadgets
open RevHalt.Dynamics.Operative.P_NP.CookLevinTableau
open RevHalt.Dynamics.Operative.P_NP.PNP

abbrev Assign := CookLevinGadgets.Var → Bool

/-- Evaluate variable with function assignment. -/
def evalVar' (A : Assign) (v : CookLevinGadgets.Var) : Bool := A v

def evalLit' (A : Assign) (ℓ : CNF.Lit) : Bool :=
  let b := evalVar' A ℓ.v
  if ℓ.neg then !b else b

def evalClause' (A : Assign) (C : CNF.Clause) : Bool :=
  C.any (evalLit' A)

def evalCNF' (A : Assign) (F : CNF.CNF) : Bool :=
  F.all (evalClause' A)

/-- A variable assignment satisfies a formula. -/
def Sat (A : Assign) (F : CNF.CNF) : Prop := evalCNF' A F = true

/-! ### Gadget Lemmas (Pure Boolean Logic) -/

theorem sat_andCNF {A : Assign} {F G : CNF.CNF} :
    Sat A (andCNF F G) ↔ Sat A F ∧ Sat A G := by
  unfold Sat andCNF evalCNF'
  simp only [List.all_append, Bool.and_eq_true]

theorem sat_andCNFs {A : Assign} {Fs : List CNF.CNF} :
    Sat A (andCNFs Fs) ↔ ∀ F ∈ Fs, Sat A F := by
  unfold Sat andCNFs evalCNF'
  induction Fs with
  | nil =>
    simp only [List.flatten_nil, List.all_nil, List.not_mem_nil, false_implies, implies_true]
  | cons F Fs ih =>
    simp only [List.flatten_cons, List.all_append, Bool.and_eq_true, List.mem_cons,
               forall_eq_or_imp]
    exact and_congr Iff.rfl ih

theorem sat_impClause {A : Assign} {ante : List CNF.Lit} {cons : CNF.Lit} :
    Sat A [impClause ante cons] ↔
      ((∀ l ∈ ante, evalLit' A l = true) → evalLit' A cons = true) := by
  unfold Sat evalCNF' impClause
  simp only [List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_append,
             List.any_map, Bool.or_eq_true]
  -- Key lemma: evalLit' A (notLit l) = !evalLit' A l
  have evalNotLit : ∀ l, evalLit' A (notLit l) = !evalLit' A l := by
    intro l
    simp only [evalLit', notLit, evalVar']
    cases hl : l.neg <;> simp
  constructor
  · intro hOr hAnte
    rcases hOr with hNeg | hCons
    · -- Some negated literal is true → contradiction
      simp only [List.any_eq_true, Function.comp_apply] at hNeg
      rcases hNeg with ⟨l, hl_mem, hl_eval⟩
      rw [evalNotLit] at hl_eval
      have hAnte_l := hAnte l hl_mem
      simp only [Bool.not_eq_true'] at hl_eval
      simp_all
    · -- Consequent is true directly
      simp only [List.any_cons, List.any_nil, Bool.or_false] at hCons
      exact hCons
  · intro hImp
    by_cases hAll : ∀ l ∈ ante, evalLit' A l = true
    · right
      simp only [List.any_cons, List.any_nil, Bool.or_false]
      exact hImp hAll
    · left
      push_neg at hAll
      rcases hAll with ⟨l, hl_mem, hl_false⟩
      simp only [List.any_eq_true, Function.comp_apply]
      use l, hl_mem
      rw [evalNotLit]
      simp only [Bool.not_eq_true', Bool.eq_false_iff] at hl_false ⊢
      exact hl_false

theorem sat_atLeastOne {A : Assign} {lits : List CookLevinGadgets.Var} (h : lits ≠ []) :
    Sat A (atLeastOne lits) ↔ ∃ v ∈ lits, A v = true := by
  unfold Sat evalCNF' atLeastOne
  cases lits with
  | nil => contradiction
  | cons x xs =>
    simp only [List.all_cons, List.all_nil, Bool.and_true, evalClause',
               List.any_map, List.any_eq_true, Function.comp_apply]
    constructor
    · intro ⟨v, hv_mem, hv_eval⟩
      use v, hv_mem
      simp only [evalLit', pos, evalVar'] at hv_eval
      exact hv_eval
    · intro ⟨v, hv_mem, hv_true⟩
      use v, hv_mem
      simp only [evalLit', pos, evalVar']
      exact hv_true

/-! ## A0. Lemmes de base sur les clauses unitaires et disjonctions -/

theorem sat_unit_pos {A : Assign} {v : CookLevinGadgets.Var} :
    Sat A [[pos v]] ↔ A v = true := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_cons, List.any_nil, Bool.or_false, evalLit', pos, evalVar']
  cases A v <;> decide

theorem sat_unit_neg {A : Assign} {v : CookLevinGadgets.Var} :
    Sat A [[neg v]] ↔ A v = false := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_cons, List.any_nil, Bool.or_false, evalLit', neg, evalVar']
  cases A v <;> decide

theorem sat_bigOr_pos {A : Assign} {vs : List CookLevinGadgets.Var} :
    Sat A [vs.map pos] ↔ ∃ v ∈ vs, A v = true := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause']
  rw [List.any_map]
  simp only [evalLit', pos, evalVar', Function.comp_apply, List.any_eq_true]
  rfl

theorem sat_andCNFs_iff {A : Assign} {Fs : List CNF.CNF} :
    Sat A (andCNFs Fs) ↔ ∀ F ∈ Fs, Sat A F := by
  unfold andCNFs Sat evalCNF'
  rw [List.all_flatten, List.all_eq_true]

theorem mem_pairwise_subset {α} (l : List α) (x y : α) :
    (x, y) ∈ pairwise l → x ∈ l ∧ y ∈ l := by
  induction l with
  | nil => simp [pairwise]
  | cons h t ih =>
    intro H
    simp only [pairwise, List.mem_append, List.mem_map] at H
    cases H with
    | inl hmap =>
      rcases hmap with ⟨z, hz, heq⟩
      injection heq with hx hy
      subst hx; subst hy
      simp [hz]
    | inr hpair =>
      cases ih hpair with | intro ix iy =>
      simp [ix, iy]

theorem distinct_of_mem_pairwise {α} [DecidableEq α] (l : List α) (hl : l.Nodup) (x y : α) :
    (x, y) ∈ pairwise l → x ≠ y := by
  induction l with
  | nil => simp [pairwise]
  | cons h t ih =>
    rw [List.nodup_cons] at hl
    rcases hl with ⟨hnotin, htail⟩
    intro H
    simp only [pairwise, List.mem_append, List.mem_map] at H
    cases H with
    | inl hmap =>
      rcases hmap with ⟨z, hz, heq⟩
      injection heq with hx hy
      subst hx
      subst hy
      intro heq
      subst heq
      exact hnotin hz
    | inr hpair =>
      exact ih htail hpair

theorem exists_pair_of_mem_distinct {α} [DecidableEq α] (l : List α) (x y : α) :
    x ∈ l → y ∈ l → x ≠ y → (x, y) ∈ pairwise l ∨ (y, x) ∈ pairwise l := by
  induction l with
  | nil => simp
  | cons h t ih =>
    intro hx hy hne
    simp only [List.mem_cons] at hx hy
    simp only [pairwise, List.mem_append, List.mem_map]
    rcases hx with rfl | hxt
    · rcases hy with rfl | hyt
      · contradiction
      · left; left; use y;
    · rcases hy with rfl | hyt
      · right; left; use x;
      · rcases ih hxt hyt hne with h1 | h2
        · left; right; exact h1
        · right; right; exact h2

theorem sat_atMostOne {A : Assign} {lits : List CookLevinGadgets.Var} (hNd : lits.Nodup) :
    Sat A (atMostOne lits) ↔
      ∀ v ∈ lits, ∀ v' ∈ lits, v ≠ v' → ¬(A v = true ∧ A v' = true) := by
  simp only [Sat, evalCNF', atMostOne]
  rw [List.all_map, List.all_eq_true]
  simp only [Function.comp_apply]
  constructor
  · intro h v hv v' hv' hne
    cases exists_pair_of_mem_distinct lits v v' hv hv' hne with
    | inl hpair =>
      specialize h (v, v') hpair
      simp [evalClause', evalLit', neg, evalVar'] at h
      intro hAnd
      rw [hAnd.1, hAnd.2] at h
      simp at h
    | inr hpair =>
      specialize h (v', v) hpair
      simp [evalClause', evalLit', neg, evalVar'] at h
      intro hAnd
      rw [hAnd.1, hAnd.2] at h
      simp at h
  · intro H p hp
    have : p.1 ∈ lits ∧ p.2 ∈ lits := mem_pairwise_subset lits p.1 p.2 hp
    specialize H p.1 this.1 p.2 this.2 (distinct_of_mem_pairwise lits hNd p.1 p.2 hp)
    simp [evalClause', evalLit', neg, evalVar']
    cases h1 : A p.1 <;> cases h2 : A p.2 <;> simp [h1, h2] at H ⊢

theorem sat_andCNF_pair {A : Assign} {F G : CNF.CNF} : Sat A (andCNF F G) ↔ Sat A F ∧ Sat A G := by
  unfold andCNF Sat evalCNF'
  simp only [List.all_append, Bool.and_eq_true]

theorem sat_exactlyOne {A : Assign} {lits : List CookLevinGadgets.Var} (h : lits ≠ []) (hNd : lits.Nodup) :
    Sat A (exactlyOne lits) ↔
      (∃ v ∈ lits, A v = true) ∧
      (∀ v ∈ lits, ∀ v' ∈ lits, v ≠ v' → ¬(A v = true ∧ A v' = true)) := by
  unfold exactlyOne
  rw [sat_andCNF_pair]
  unfold atLeastOne
  split
  · contradiction
  · rw [sat_bigOr_pos, sat_atMostOne hNd]

/-! ### Assign ↔ Witness Bridge API -/

/-- Max variable index used by a literal. -/
def maxVarLit (ℓ : CNF.Lit) : ℕ := ℓ.v

/-- Max variable index used by a clause. -/
def maxVarClause (C : CNF.Clause) : ℕ :=
  C.foldl (fun acc ℓ => max acc (maxVarLit ℓ)) 0

/-- Max variable index used by a CNF formula. -/
def maxVar (F : CNF.CNF) : ℕ :=
  F.foldl (fun acc C => max acc (maxVarClause C)) 0

/-- Turn a PNP.Witness (List Bool) into an assignment function with default false. -/
def assignOfWitness (w : PNP.Witness) : Assign :=
  fun v => w.getD v false

/-- Turn an assignment function into a PNP.Witness list of length L. -/
def witnessOfAssign (L : ℕ) (A : Assign) : PNP.Witness :=
  (List.range L).map A

/-- Witness size of witnessOfAssign is exactly L. -/
theorem witnessOfAssign_size (L : ℕ) (A : Assign) :
    PNP.witnessSize (witnessOfAssign L A) = L := by
  unfold witnessOfAssign PNP.witnessSize
  simp only [List.length_map, List.length_range]

/-- assignOfWitness ∘ witnessOfAssign recovers A for indices < L. -/
theorem assignOfWitness_witnessOfAssign (L : ℕ) (A : Assign) (v : ℕ) (hv : v < L) :
    assignOfWitness (witnessOfAssign L A) v = A v := by
  dsimp [assignOfWitness, witnessOfAssign]
  -- Robust range append lemma
  have range_append : ∀ n, List.range (n + 1) = List.range n ++ [n] := by
    intro n
    induction n with
    | zero => rfl
    | succ n ih => rw [List.range_succ, ih]

  -- Main property using getD to avoid dependent type issues
  have map_range_getD : ∀ (n : ℕ) (i : ℕ), i < n → (List.map A (List.range n)).getD i false = A i := by
    intro n
    induction n with
    | zero => intro i h; contradiction
    | succ n ih =>
      intro i h_lt
      rw [range_append, List.map_append]
      simp only [List.map_cons, List.map_nil]

      have getD_append_lt : ∀ (l : List Bool) (x : Bool) (k : ℕ) (d : Bool), k < l.length → (l ++ [x]).getD k d = l.getD k d := by
        intro l x k d h
        induction l generalizing k with
        | nil => contradiction
        | cons h t ih =>
          cases k with
          | zero => rfl
          | succ k' => simp [List.getD]; apply ih; simp [List.length] at h; exact h

      have getD_append_eq : ∀ (l : List Bool) (x : Bool) (d : Bool), (l ++ [x]).getD l.length d = x := by
        intro l x d
        induction l with
        | nil => rfl
        | cons h t ih => simp [List.getD, List.length];

      if h : i < n then
        rw [getD_append_lt]
        · exact ih i h
        · simp [List.length_map, List.length_range]; exact h
      else
        have h_eq : i = n := by
          apply Nat.le_antisymm
          · apply Nat.le_of_lt_succ h_lt
          · apply Nat.le_of_not_lt h
        rw [h_eq]
        -- Goal: (map ... ++ [A n]).getD n false = A n
        have h_len : (List.map A (List.range n)).length = n := by simp [List.length_range]
        convert getD_append_eq (List.map A (List.range n)) (A n) false
        exact h_len.symm

  apply map_range_getD L v hv

/-- Monotonicity of foldl max. -/
theorem foldl_max_mono (l : List α) (f : α → ℕ) (init : ℕ) :
    init ≤ l.foldl (fun acc y => max acc (f y)) init := by
  induction l generalizing init with
  | nil => simp only [List.foldl_nil, Nat.le_refl]
  | cons h t ih =>
    simp only [List.foldl_cons]
    apply Nat.le_trans (Nat.le_max_left _ _) (ih _)

/-- Helper for maxVar bound found in folds. -/
theorem foldl_max_le {l : List α} {f : α → ℕ} {init : ℕ} (x : α) (hx : x ∈ l) :
    f x ≤ l.foldl (fun acc y => max acc (f y)) init := by
  induction l generalizing init with
  | nil => contradiction
  | cons head tail ih =>
    simp only [List.foldl_cons, List.mem_cons] at hx ⊢
    cases hx with
    | inl h_eq =>
      subst h_eq
      apply Nat.le_trans (m := max init (f x))
      · apply Nat.le_max_right
      · apply foldl_max_mono
    | inr h_in =>
      apply ih (init := max init (f head))
      exact h_in

theorem maxVar_bound (F : CNF.CNF) :
    ∀ C ∈ F, ∀ ℓ ∈ C, ℓ.v ≤ maxVar F := by
  intro C hC ℓ hℓ
  unfold maxVar
  have hC_le := foldl_max_le (f := maxVarClause) C hC (init := 0)
  apply Nat.le_trans _ hC_le
  unfold maxVarClause
  exact foldl_max_le (f := maxVarLit) ℓ hℓ (init := 0)

/-- If all vars in F are < maxVar F + 1, then Sat via assignment ↔ evalCNF via padded witness. -/
theorem sat_iff_evalCNF_witness (A : Assign) (F : CNF.CNF) :
    Sat A F ↔ CNF.evalCNF (witnessOfAssign (maxVar F + 1) A) F = true := by
  have sat_iff_eval_of_bound : ∀ L, maxVar F < L → (Sat A F ↔ CNF.evalCNF (witnessOfAssign L A) F = true) := by
    intro L hL
    rw [Sat, evalCNF', CNF.evalCNF]
    simp only [List.all_eq_true, List.any_eq_true, evalClause', CNF.evalClause, evalLit', CNF.evalLit, CNF.evalVar]
    apply forall_congr'
    intro C
    apply imp_congr_right
    intro hC
    apply exists_congr
    intro ℓ
    apply and_congr_right
    intro hℓ
    -- Goal: A ℓ.v ... ↔ witness ... ℓ.v ...
    have hv : ℓ.v < L := Nat.lt_of_le_of_lt (maxVar_bound F C hC ℓ hℓ) hL
    have h_rw : (witnessOfAssign L A).getD ℓ.v false = A ℓ.v := assignOfWitness_witnessOfAssign L A ℓ.v hv
    rw [h_rw]
    rfl

  exact sat_iff_eval_of_bound (maxVar F + 1) (Nat.lt_succ_self _)

/-- Bridge: satisfiable via assignment ↔ satisfiable via bounded PNP.Witness. -/
theorem sat_assign_iff_sat_witness (F : CNF.CNF) :
    (∃ A : Assign, Sat A F) ↔
    (∃ w : PNP.Witness, PNP.witnessSize w ≤ (maxVar F + 1) ∧ CNF.evalCNF w F = true) := by
  constructor
  · rintro ⟨A, hA⟩
    use witnessOfAssign (maxVar F + 1) A
    constructor
    · rw [witnessOfAssign_size]
    · rw [← sat_iff_evalCNF_witness]
      exact hA
  · rintro ⟨w, _, hw⟩
    use assignOfWitness w
    unfold Sat evalCNF'
    unfold CNF.evalCNF at hw
    simp only [List.all_eq_true]
    intro C hC
    simp only [List.all_eq_true] at hw
    specialize hw C hC
    simp only [evalClause', List.any_eq_true]
    simp only [CNF.evalClause, List.any_eq_true] at hw
    obtain ⟨ℓ, hℓ, hl_true⟩ := hw
    use ℓ, hℓ
    simp only [evalLit']
    exact hl_true

/-- Equivalence between witness-based and assignment-based satisfiability. -/
theorem satisfiable_iff_exists_sat_assign (F : CNF.CNF) :
    CNF.Satisfiable F ↔ ∃ A : Assign, Sat A F := by
  constructor
  · rintro ⟨w, hw⟩
    use assignOfWitness w
    -- They are definitionally equal check?
    -- Sat (assignOfWitness w) F := evalCNF' (assignOfWitness w) F = true
    -- evalCNF w F = true
    -- Let's check definitions logic.
    -- evalVar' (assignOfWitness w) v = (assignOfWitness w) v = w.getD v false
    -- CNF.evalVar w v = w.getD v false
    -- So they are equal.
    convert hw
  · rintro ⟨A, hA⟩
    rw [sat_iff_evalCNF_witness] at hA
    exact ⟨_, hA⟩

/-- Bridge to SATBundle: if maxVar + 1 fits in wBound, we get the right form. -/
theorem satisfiable_bounded_iff_satisfiable
    (wBound : ℕ) (F : CNF.CNF)
    (h : maxVar F + 1 ≤ wBound) :
    CNF.Satisfiable F ↔
      (∃ w : PNP.Witness, PNP.witnessSize w ≤ wBound ∧ CNF.evalCNF w F = true) := by
  constructor
  · intro hSat
    -- Satisfiable -> ∃ A, Sat A F
    rcases (satisfiable_iff_exists_sat_assign (F := F)).1 hSat with ⟨A, hA⟩
    -- ∃ A, Sat A F -> bounded witness (≤ maxVar+1)
    rcases (sat_assign_iff_sat_witness (F := F)).1 ⟨A, hA⟩ with ⟨w, hwSize, hwEval⟩
    refine ⟨w, Nat.le_trans hwSize h, hwEval⟩
  · rintro ⟨w, _, hwEval⟩
    exact ⟨w, hwEval⟩



/-! ## A1. Décomposition de genTableauAll en conjonction de composants -/

theorem sat_genTableauAll_iff
    {A : Assign} (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) ↔
      Sat A (uniqueState T M.numStates) ∧
      Sat A (uniqueHead  T S) ∧
      Sat A (uniqueTape  T S M.numSymbols) ∧
      Sat A (uniqueStep  T M.numRules) ∧
      Sat A (genTransition T S M) ∧
      Sat A (genInertia   T S M.numSymbols) ∧
      Sat A (genInitConst S q0 head0 tape0 witOff witLen) ∧
      Sat A (genInitWitness witLen witOff sym0 sym1) ∧
      Sat A (genAccept T qAcc) := by
  unfold genTableauAll
  rw [sat_andCNFs_iff]
  constructor
  · intro h
    simp only [List.mem_cons] at h
    repeat' constructor
    all_goals apply h; simp
  · intro h F hF
    simp only [List.mem_cons] at hF
    rcases h with ⟨h1, h2, h3, h4, h5, h6, h7, h8, h9⟩
    rcases hF with rfl | rfl | rfl | rfl | rfl | rfl | rfl | rfl | rfl | hFalse
    · exact h1
    · exact h2
    · exact h3
    · exact h4
    · exact h5
    · exact h6
    · exact h7
    · exact h8
    · exact h9
    · cases hFalse

/-! ## A2. Extraction "uniqueState/head/tape/step" depuis Sat -/

/-- Extract the unique state at time t from a satisfying assignment. -/
def stateOf (A : Assign) (_T numStates : ℕ) (t : ℕ) : ℕ :=
  ((List.range numStates).find? (fun q => A (varState t q))).getD 0


private
theorem find?_one_mem_pred {α : Type} {p : α → Bool} {l : List α} {d : α}
    (h : ∃ x ∈ l, p x = true) :
    let res := (l.find? p).getD d
    res ∈ l ∧ p res = true := by
  induction l with
  | nil =>
    rcases h with ⟨_, hfalse, _⟩
    contradiction
  | cons a l ih =>
    dsimp [List.find?]
    split
    next hpa =>
      simp only [Option.getD_some]
      constructor
      · apply List.mem_cons_self
      · exact hpa
    next hpa_false =>
    next hpa_false =>
      rcases h with ⟨x, hx_mem, hx_p⟩
      simp only [List.mem_cons] at hx_mem
      have h_tail : ∃ x ∈ l, p x = true := by
        rcases hx_mem with rfl | hx_mem_tail
        · rw [hx_p] at hpa_false; contradiction
        · exact ⟨x, hx_mem_tail, hx_p⟩
      specialize ih h_tail
      constructor
      · exact List.mem_cons_of_mem _ ih.1
      · exact ih.2

private theorem var_inj_helper (t tag : ℕ) :
    Function.Injective (fun x => mkVar tag t x 0) := by
  intro x y h
  simp only [mkVar, Nat.pair_eq_pair] at h
  rcases h with ⟨_, h2⟩
  rcases h2 with ⟨_, h3⟩
  rcases h3 with ⟨res, _⟩
  exact res

private theorem varState_inj (t : ℕ) : Function.Injective (fun q => varState t q) :=
  var_inj_helper t tagState

private def stateVars (t numStates : ℕ) : List CookLevinGadgets.Var :=
  (List.range numStates).map (fun q => varState t q)

private theorem stateVars_nodup (t numStates : ℕ) :
    (stateVars t numStates).Nodup :=
  List.Nodup.map (varState_inj t) List.nodup_range

theorem stateOf_spec
    {A : Assign} {T numStates t : ℕ}
    (hU : Sat A (uniqueState T numStates)) (ht : t ≤ T)
    (hNum : numStates > 0) :
    stateOf A T numStates t < numStates ∧
    A (varState t (stateOf A T numStates t)) = true ∧
    (∀ q < numStates, q ≠ stateOf A T numStates t → A (varState t q) = false) := by
  change Sat A (andCNFs ((List.range (T + 1)).map (fun t => exactlyOne (stateVars t numStates)))) at hU
  rw [sat_andCNFs_iff] at hU
  have hEx1 : Sat A (exactlyOne (stateVars t numStates)) := by
    apply hU
    simp only [List.mem_map, List.mem_range]
    exact ⟨t, Nat.lt_succ_of_le ht, rfl⟩

  let vars := stateVars t numStates
  have hNe : vars ≠ [] := by
    intro hEmpty
    dsimp [vars] at hEmpty
    rw [stateVars] at hEmpty
    simp at hEmpty
    linarith

  have hNd : vars.Nodup := stateVars_nodup t numStates
  have hSat := (sat_exactlyOne hNe hNd).mp hEx1
  obtain ⟨hAtLeastOne, hAtMostOne⟩ := hSat

  have hExists : ∃ q, q ∈ List.range numStates ∧ A (varState t q) = true := by
    rcases hAtLeastOne with ⟨v, hvMem, hvTrue⟩
    change v ∈ (List.range numStates).map (varState t) at hvMem
    rw [List.mem_map] at hvMem
    rcases hvMem with ⟨q, hqMem, rfl⟩
    exact ⟨q, hqMem, hvTrue⟩

  let q0 := stateOf A T numStates t
  have hFind : q0 ∈ List.range numStates ∧ A (varState t q0) = true := by
    dsimp [stateOf]
    apply find?_one_mem_pred hExists

  refine ⟨List.mem_range.mp hFind.1, hFind.2, ?_⟩
  intro q hqLt hqNe
  by_contra hContra
  simp only [Bool.not_eq_false] at hContra
  apply hAtMostOne (varState t q) _ (varState t q0) _ _ ⟨hContra, hFind.2⟩
  · change varState t q ∈ (List.range numStates).map (varState t)
    rw [List.mem_map]
    use q
    constructor
    · rw [List.mem_range]; exact hqLt
    · rfl
  · change varState t q0 ∈ (List.range numStates).map (varState t)
    rw [List.mem_map]
    use q0
    constructor
    · exact hFind.1
    · rfl
  · intro hEq; apply hqNe; exact varState_inj t hEq
/-- Extract the unique head position at time t from a satisfying assignment. -/
def headOf (A : Assign) (_T S : ℕ) (t : ℕ) : ℕ :=
  ((List.range S).find? (fun k => A (varHead t k))).getD 0


private theorem varHead_inj (t : ℕ) : Function.Injective (fun k => varHead t k) :=
  var_inj_helper t tagHead

private def headVars (t S : ℕ) : List CookLevinGadgets.Var :=
  (List.range S).map (fun k => varHead t k)

private theorem headVars_nodup (t S : ℕ) : (headVars t S).Nodup :=
  List.Nodup.map (varHead_inj t) List.nodup_range

theorem headOf_spec
    {A : Assign} {T S t : ℕ}
    (hU : Sat A (uniqueHead T S)) (ht : t ≤ T) (hS : S > 0) :
    headOf A T S t < S ∧
    A (varHead t (headOf A T S t)) = true ∧
    (∀ k < S, k ≠ headOf A T S t → A (varHead t k) = false) := by
  change Sat A (andCNFs ((List.range (T + 1)).map (fun t => exactlyOne (headVars t S)))) at hU
  rw [sat_andCNFs_iff] at hU
  have hEx1 : Sat A (exactlyOne (headVars t S)) := by
    apply hU
    simp only [List.mem_map, List.mem_range]
    exact ⟨t, Nat.lt_succ_of_le ht, rfl⟩

  let vars := headVars t S
  have hNe : vars ≠ [] := by
    intro hEmpty
    dsimp [vars] at hEmpty
    rw [headVars] at hEmpty
    simp at hEmpty
    linarith

  have hNd : vars.Nodup := headVars_nodup t S
  have hSat := (sat_exactlyOne hNe hNd).mp hEx1
  obtain ⟨hAtLeastOne, hAtMostOne⟩ := hSat

  have hExists : ∃ k, k ∈ List.range S ∧ A (varHead t k) = true := by
    rcases hAtLeastOne with ⟨v, hvMem, hvTrue⟩
    change v ∈ (List.range S).map (varHead t) at hvMem
    rw [List.mem_map] at hvMem
    rcases hvMem with ⟨k, hkMem, rfl⟩
    exact ⟨k, hkMem, hvTrue⟩

  let k0 := headOf A T S t
  have hFind : k0 ∈ List.range S ∧ A (varHead t k0) = true := by
    dsimp [headOf]
    apply find?_one_mem_pred hExists

  refine ⟨List.mem_range.mp hFind.1, hFind.2, ?_⟩
  intro k hkLt hkNe
  by_contra hContra
  simp only [Bool.not_eq_false] at hContra
  apply hAtMostOne (varHead t k) _ (varHead t k0) _ _ ⟨hContra, hFind.2⟩
  · change varHead t k ∈ (List.range S).map (varHead t)
    rw [List.mem_map]
    use k
    constructor
    · rw [List.mem_range]; exact hkLt
    · rfl
  · change varHead t k0 ∈ (List.range S).map (varHead t)
    rw [List.mem_map]
    use k0
    constructor
    · exact hFind.1
    · rfl
  · intro hEq; apply hkNe; exact varHead_inj t hEq/-- Extract the unique tape symbol at (t, k) from a satisfying assignment. -/
def tapeOf (A : Assign) (_T _S numSymbols : ℕ) (t k : ℕ) : ℕ :=
  ((List.range numSymbols).find? (fun s => A (varTape t k s))).getD 0


private theorem varTape_inj (t k : ℕ) : Function.Injective (fun s => varTape t k s) := by
  intro s s' h
  simp only [varTape, mkVar, Nat.pair_eq_pair] at h
  rcases h with ⟨_, h2⟩
  rcases h2 with ⟨_, h3⟩
  rcases h3 with ⟨_, h4⟩
  exact h4

private def tapeVars (t k numSymbols : ℕ) : List CookLevinGadgets.Var :=
  (List.range numSymbols).map (fun s => varTape t k s)

private theorem tapeVars_nodup (t k numSymbols : ℕ) : (tapeVars t k numSymbols).Nodup :=
  List.Nodup.map (varTape_inj t k) List.nodup_range

theorem tapeOf_spec
    {A : Assign} {T S numSymbols t k : ℕ}
    (hU : Sat A (uniqueTape T S numSymbols)) (ht : t ≤ T) (hk : k < S)
    (hSym : numSymbols > 0) :
    tapeOf A T S numSymbols t k < numSymbols ∧
    A (varTape t k (tapeOf A T S numSymbols t k)) = true ∧
    (∀ s < numSymbols, s ≠ tapeOf A T S numSymbols t k → A (varTape t k s) = false) := by
  change Sat A (andCNFs ((List.range (T + 1)).map (fun t => (List.range S).flatMap (fun k => exactlyOne (tapeVars t k numSymbols))))) at hU
  rw [sat_andCNFs_iff] at hU
  have hSatBig : Sat A ((List.range S).flatMap (fun k => exactlyOne (tapeVars t k numSymbols))) := by
    apply hU
    simp only [List.mem_map, List.mem_range]
    use t
    constructor
    · apply Nat.lt_succ_of_le ht
    · rfl
  change Sat A (andCNFs ((List.range S).map (fun k => exactlyOne (tapeVars t k numSymbols)))) at hSatBig
  rw [sat_andCNFs_iff] at hSatBig
  have hEx1 : Sat A (exactlyOne (tapeVars t k numSymbols)) := by
    apply hSatBig
    simp only [List.mem_map, List.mem_range]
    use k

  let vars := tapeVars t k numSymbols
  have hNe : vars ≠ [] := by
    intro hEmpty
    dsimp [vars] at hEmpty
    rw [tapeVars] at hEmpty
    simp at hEmpty
    linarith

  have hNd : vars.Nodup := tapeVars_nodup t k numSymbols
  have hSat := (sat_exactlyOne hNe hNd).mp hEx1
  obtain ⟨hAtLeastOne, hAtMostOne⟩ := hSat

  have hExists : ∃ s, s ∈ List.range numSymbols ∧ A (varTape t k s) = true := by
    rcases hAtLeastOne with ⟨v, hvMem, hvTrue⟩
    change v ∈ (List.range numSymbols).map (varTape t k) at hvMem
    rw [List.mem_map] at hvMem
    rcases hvMem with ⟨s, hsMem, rfl⟩
    exact ⟨s, hsMem, hvTrue⟩

  let s0 := tapeOf A T S numSymbols t k
  have hFind : s0 ∈ List.range numSymbols ∧ A (varTape t k s0) = true := by
    dsimp [tapeOf]
    apply find?_one_mem_pred hExists

  refine ⟨List.mem_range.mp hFind.1, hFind.2, ?_⟩
  intro s hsLt hsNe
  by_contra hContra
  simp only [Bool.not_eq_false] at hContra
  apply hAtMostOne (varTape t k s) _ (varTape t k s0) _ _ ⟨hContra, hFind.2⟩
  · change varTape t k s ∈ (List.range numSymbols).map (varTape t k)
    rw [List.mem_map]
    use s
    constructor
    · rw [List.mem_range]; exact hsLt
    · rfl
  · change varTape t k s0 ∈ (List.range numSymbols).map (varTape t k)
    rw [List.mem_map]
    use s0
    constructor
    · exact hFind.1
    · rfl
  · intro hEq; apply hsNe; exact varTape_inj t k hEq/-- Extract the unique step/rule index at time t from a satisfying assignment. -/
def stepOf (A : Assign) (_T numRules : ℕ) (t : ℕ) : ℕ :=
  ((List.range numRules).find? (fun r => A (varStep t r))).getD 0


private theorem varStep_inj (t : ℕ) : Function.Injective (fun r => varStep t r) :=
  var_inj_helper t tagStep

private def stepVars (t numRules : ℕ) : List CookLevinGadgets.Var :=
  (List.range numRules).map (fun r => varStep t r)

private theorem stepVars_nodup (t numRules : ℕ) : (stepVars t numRules).Nodup :=
  List.Nodup.map (varStep_inj t) List.nodup_range

theorem stepOf_spec
    {A : Assign} {T numRules t : ℕ}
    (hU : Sat A (uniqueStep T numRules)) (ht : t < T)
    (hRules : numRules > 0) :
    stepOf A T numRules t < numRules ∧
    A (varStep t (stepOf A T numRules t)) = true ∧
    (∀ r < numRules, r ≠ stepOf A T numRules t → A (varStep t r) = false) := by
  change Sat A (andCNFs ((List.range T).map (fun t => exactlyOne (stepVars t numRules)))) at hU
  rw [sat_andCNFs_iff] at hU
  have hEx1 : Sat A (exactlyOne (stepVars t numRules)) := by
    apply hU
    simp only [List.mem_map, List.mem_range]
    exact ⟨t, ht, rfl⟩

  let vars := stepVars t numRules
  have hNe : vars ≠ [] := by
    intro hEmpty
    dsimp [vars] at hEmpty
    simp only [stepVars] at hEmpty
    simp at hEmpty
    linarith

  have hNd : vars.Nodup := stepVars_nodup t numRules
  have hSat := (sat_exactlyOne hNe hNd).mp hEx1
  obtain ⟨hAtLeastOne, hAtMostOne⟩ := hSat

  have hExists : ∃ r, r ∈ List.range numRules ∧ A (varStep t r) = true := by
    rcases hAtLeastOne with ⟨v, hvMem, hvTrue⟩
    simp [vars] at hvMem
    simp only [stepVars] at hvMem
    rw [List.mem_map (f := fun r => varStep t r)] at hvMem
    rcases hvMem with ⟨r, hrMem, rfl⟩
    exact ⟨r, hrMem, hvTrue⟩

  let r0 := stepOf A T numRules t
  have hFind : r0 ∈ List.range numRules ∧ A (varStep t r0) = true := by
    dsimp [stepOf]
    apply find?_one_mem_pred hExists

  refine ⟨List.mem_range.mp hFind.1, hFind.2, ?_⟩
  intro r hrLt hrNe
  by_contra hContra
  simp only [Bool.not_eq_false] at hContra
  apply hAtMostOne (varStep t r) _ (varStep t r0) _ _ ⟨hContra, hFind.2⟩
  · change varStep t r ∈ (List.range numRules).map (varStep t)
    rw [List.mem_map]
    use r
    constructor
    · rw [List.mem_range]; exact hrLt
    · rfl
  · change varStep t r0 ∈ (List.range numRules).map (varStep t)
    rw [List.mem_map]
    use r0
    constructor
    · exact hFind.1
    · rfl
  · intro hEq; apply hrNe; exact varStep_inj t hEq/-! ## A3. Init / Witness / Accept sous forme "logique" -/

theorem sat_genInitConst_iff
    {A : Assign} (S q0 head0 : ℕ) (tape0 : ℕ → ℕ) (witOff witLen : ℕ) :
    Sat A (genInitConst S q0 head0 tape0 witOff witLen) ↔
      A (varState 0 q0) = true ∧
      A (varHead  0 head0) = true ∧
      (∀ k < S, (k < witOff ∨ k ≥ witOff + witLen) → A (varTape 0 k (tape0 k)) = true) := by
  unfold genInitConst
  dsimp only [CookLevinGadgets.pos, CNF.Lit.neg]
  simp [Sat, evalCNF', evalClause', evalLit', evalVar', List.all_eq_true]
  intros
  apply forall_congr'; intro k
  apply forall_congr'; intro hkS
  rw [imp_iff_not_or]
  simp [not_or, not_lt, not_le]

theorem sat_genInitWitness_iff
    {A : Assign} (witLen witOff sym0 sym1 : ℕ) :
    Sat A (genInitWitness witLen witOff sym0 sym1) ↔
      ∀ i < witLen,
        (A (varWit i) = true  → A (varTape 0 (witOff + i) sym1) = true) ∧
        (A (varWit i) = false → A (varTape 0 (witOff + i) sym0) = true) := by

  unfold genInitWitness
  simp only [Sat, evalCNF', List.all_eq_true]
  simp only [List.mem_flatMap, forall_exists_index, and_imp, List.mem_range]
  rw [forall_comm]
  apply forall_congr'; intro i
  constructor
  · -- Forward direction: Sat → semantic property
    intro h hi
    constructor
    · -- A (varWit i) = true → A (varTape 0 (witOff + i) sym1) = true
      intro hw
      have mem : impClause [pos (varWit i)] (pos (varTape 0 (witOff + i) sym1)) ∈
        [impClause [pos (varWit i)] (pos (varTape 0 (witOff + i) sym1)),
         impClause [neg (varWit i)] (pos (varTape 0 (witOff + i) sym0))] := by simp
      specialize h _ hi mem
      simp only [impClause, evalClause', List.any_eq_true, List.mem_append, List.mem_map,
                 List.mem_singleton, notLit, pos, evalLit', evalVar'] at h
      rcases h with ⟨lit, hMem, hEval⟩
      rcases hMem with ⟨orig, rfl, rfl⟩ | rfl
      · simp_all
      · simp_all
    · -- A (varWit i) = false → A (varTape 0 (witOff + i) sym0) = true
      intro hw
      have mem : impClause [neg (varWit i)] (pos (varTape 0 (witOff + i) sym0)) ∈
        [impClause [pos (varWit i)] (pos (varTape 0 (witOff + i) sym1)),
         impClause [neg (varWit i)] (pos (varTape 0 (witOff + i) sym0))] := by simp
      specialize h _ hi mem
      simp only [impClause, evalClause', List.any_eq_true, List.mem_append, List.mem_map,
                 List.mem_singleton, notLit, neg, evalLit', evalVar'] at h
      rcases h with ⟨lit, hMem, hEval⟩
      rcases hMem with ⟨orig, rfl, rfl⟩ | rfl
      · simp_all
      · simp only [pos] at hEval; simp_all
  · -- Backward direction
    intro h x hi hx
    specialize h hi
    rcases h with ⟨h1, h2⟩
    simp at hx
    rcases hx with rfl | rfl
    · dsimp [impClause, evalClause', evalLit', evalVar', CNF.Lit.neg, CookLevinGadgets.pos]
      rw [imp_iff_not_or] at h1
      simpa [Bool.or_eq_true] using h1
    · dsimp [impClause, evalClause', evalLit', evalVar', CNF.Lit.neg, CookLevinGadgets.pos, CookLevinGadgets.neg]
      rw [imp_iff_not_or] at h2
      simpa [Bool.or_eq_true] using h2

theorem sat_genAccept_iff
    {A : Assign} (T qAcc : ℕ) :
    Sat A (genAccept T qAcc) ↔ ∃ t ≤ T, A (varState t qAcc) = true := by
  unfold genAccept
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause']
  rw [List.any_map]
  simp only [List.any_eq_true, List.mem_range, Function.comp_apply]
  dsimp only [evalLit', evalVar', CookLevinGadgets.pos]
  constructor
  · intro ⟨t, ht, hVal⟩
    exact ⟨t, Nat.le_of_lt_succ ht, hVal⟩
  · intro ⟨t, ht, hVal⟩
    exact ⟨t, Nat.lt_succ_of_le ht, hVal⟩

/-! ## A4. Transition & inertie : lemmes locaux "stepCNF" puis globaux -/

theorem sat_stepCNF_implies
    {A : Assign} (S t k rId : ℕ) (R : TransitionRule) :
    Sat A (stepCNF S t k rId R) →
    (A (varStep t rId) = true ∧ A (varHead t k) = true) →
      A (varState t R.q) = true ∧
      A (varTape  t k R.s) = true ∧
      A (varState (t+1) R.q') = true ∧
      A (varTape  (t+1) k R.s') = true ∧
      A (varHead  (t+1) (movePos R.mv k)) = true := by
  intro hSat ⟨hStep, hHead⟩
  -- stepCNF = stepBoundary ++ stepGuard ++ stepEffect
  rw [stepCNF, Sat, evalCNF', List.all_append, List.all_append, Bool.and_eq_true, Bool.and_eq_true] at hSat
  obtain ⟨⟨_, hGuard⟩, hEffect⟩ := hSat
  -- Extract from stepGuard: two implication clauses
  simp only [stepGuard, List.all_cons, List.all_nil, Bool.and_true, Bool.and_eq_true] at hGuard
  obtain ⟨hStateGuard, hTapeGuard⟩ := hGuard
  -- Extract from stepEffect: three implication clauses
  simp only [stepEffect, List.all_cons, List.all_nil, Bool.and_true, Bool.and_eq_true] at hEffect
  obtain ⟨hStateEff, hTapeEff, hHeadEff⟩ := hEffect
  -- Simplify all clauses
  simp only [impClause, evalClause', List.any_eq_true, List.mem_append, List.mem_map,
             notLit, pos, evalLit', evalVar', List.mem_cons, List.mem_nil_iff,
             or_false] at hStateGuard hTapeGuard hStateEff hTapeEff hHeadEff
  -- Goal 1: A (varState t R.q) = true
  have h1 : A (varState t R.q) = true := by
    obtain ⟨x, hMem, hEval⟩ := hStateGuard
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- Goal 2: A (varTape t k R.s) = true
  have h2 : A (varTape t k R.s) = true := by
    obtain ⟨x, hMem, hEval⟩ := hTapeGuard
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- Goal 3: A (varState (t+1) R.q') = true
  have h3 : A (varState (t+1) R.q') = true := by
    obtain ⟨x, hMem, hEval⟩ := hStateEff
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl | rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- Goal 4: A (varTape (t+1) k R.s') = true
  have h4 : A (varTape (t+1) k R.s') = true := by
    obtain ⟨x, hMem, hEval⟩ := hTapeEff
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl | rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- Goal 5: A (varHead (t+1) (movePos R.mv k)) = true
  have h5 : A (varHead (t+1) (movePos R.mv k)) = true := by
    obtain ⟨x, hMem, hEval⟩ := hHeadEff
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl | rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  exact ⟨h1, h2, h3, h4, h5⟩

theorem sat_genTransition_implies_step_valid
    {A : Assign} (T S : ℕ) (M : TableauMachine)
    (hUst : Sat A (uniqueState T M.numStates))
    (hUhd : Sat A (uniqueHead  T S))
    (hUtp : Sat A (uniqueTape  T S M.numSymbols))
    (hUsp : Sat A (uniqueStep  T M.rules.length))
    (hR   : M.rules.length > 0)
    (hTr  : Sat A (genTransition T S M)) :
    ∀ t, (ht : t < T) →
      let rId := stepOf A T M.rules.length t
      let k   := headOf A T S t
      let r   := M.rules.get ⟨rId, (stepOf_spec hUsp ht hR).1⟩
      (stateOf A T M.numStates t = r.q) ∧
      (tapeOf A T S M.numSymbols t k = r.s) ∧
      (stateOf A T M.numStates (t+1) = r.q') ∧
      (tapeOf A T S M.numSymbols (t+1) k = r.s') ∧
      (headOf A T S (t+1) = movePos r.mv k) := by
  intro t ht
  -- Get the rule index and head position
  let rId := stepOf A T M.rules.length t
  let k   := headOf A T S t
  let r   := M.rules.get ⟨rId, (stepOf_spec hUsp ht hR).1⟩
  -- The key is: genTransition contains stepCNF S t k rId r
  -- So if we can show A (varStep t rId) = true and A (varHead t k) = true,
  -- then sat_stepCNF_implies gives us the result
  have hStepTrue : A (varStep t rId) = true := (stepOf_spec hUsp ht hR).2.1
  have hHeadTrue : A (varHead t k) = true := by
    -- headOf is defined to return the head position where the variable is true
    -- We need headOf_spec for this
    sorry
  -- Now we need to extract the CNF for this specific (t, k, rId)
  have hSatStep : Sat A (stepCNF S t k rId r) := by
    -- Extract from genTransition using flatMap membership
    sorry
  -- Apply sat_stepCNF_implies
  have hImpl := sat_stepCNF_implies S t k rId r hSatStep ⟨hStepTrue, hHeadTrue⟩
  -- Now convert to stateOf, tapeOf, headOf equalities
  constructor
  · -- stateOf A T M.numStates t = r.q
    sorry
  constructor
  · -- tapeOf A T S M.numSymbols t k = r.s
    sorry
  constructor
  · -- stateOf A T M.numStates (t+1) = r.q'
    sorry
  constructor
  · -- tapeOf A T S M.numSymbols (t+1) k = r.s'
    sorry
  · -- headOf A T S (t+1) = movePos r.mv k
    sorry

theorem sat_genInertia_implies_inertia
    {A : Assign} (T S numSymbols : ℕ)
    (hUhd : Sat A (uniqueHead T S))
    (hUtp : Sat A (uniqueTape T S numSymbols))
    (hIn  : Sat A (genInertia T S numSymbols)) :
    ∀ t < T, ∀ k < S, k ≠ headOf A T S t →
      tapeOf A T S numSymbols (t+1) k = tapeOf A T S numSymbols t k := by
  sorry

/-! ### Tableau Semantics "Run" -/

/--
A structural representation of a tableau execution trace.
Everything is total (functions on ℕ), validity is a separate predicate.
-/
structure TableauRun where
  st   : ℕ → ℕ          -- State at time t (tagState)
  hd   : ℕ → ℕ          -- Head position at time t (tagHead)
  tape : ℕ → ℕ → ℕ      -- Tape symbol at (t, k) (tagTape)
  step : ℕ → ℕ          -- Transition step index at time t (tagStep)
  wit  : ℕ → Bool       -- Witness bits (tagWit)

/--
Predicates defining a "Valid" run according to the tableau constraints.
Corresponding to `genTableauAll`.
-/
structure ValidRun
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    (R : TableauRun) : Prop where
  -- 1. Bounds
  bounds_st   : ∀ t ≤ T, R.st t < M.numStates
  bounds_hd   : ∀ t ≤ T, R.hd t < S
  bounds_tape : ∀ t ≤ T, ∀ k < S, R.tape t k < M.numSymbols
  bounds_step : ∀ t < T, R.step t < M.rules.length

  -- 2. Init
  init_st   : R.st 0 = q0
  init_hd   : R.hd 0 = head0
  init_tape : ∀ k < S, R.tape 0 k =
    if k >= witOff ∧ k < witOff + witLen then
      if R.wit (k - witOff) then sym1 else sym0
    else tape0 k

  -- 3. Steps (uses movePos for consistency)
  step_valid : ∀ t, (ht : t < T) →
    let r := M.rules.get ⟨R.step t, bounds_step t ht⟩
    R.st t = r.q ∧ R.tape t (R.hd t) = r.s ∧
    R.st (t+1) = r.q' ∧
    R.tape (t+1) (R.hd t) = r.s' ∧
    R.hd (t+1) = movePos r.mv (R.hd t)

  inertia : ∀ t < T, ∀ k < S, k ≠ R.hd t → R.tape (t+1) k = R.tape t k

  -- 4. Accept
  accept : ∃ t ≤ T, R.st t = qAcc

/-- Canonical assignment induced by a TableauRun. -/
def assignOfRun
    (_T _S : ℕ) (_M : TableauMachine) (R : TableauRun) : Assign :=
  fun v =>
    let tag := v.unpair.1
    let rest := v.unpair.2
    let a := rest.unpair.1
    let rest2 := rest.unpair.2
    let b := rest2.unpair.1
    let c := rest2.unpair.2

    if tag = tagState then R.st a = b
    else if tag = tagHead then R.hd a = b
    else if tag = tagTape then R.tape a b = c
    else if tag = tagStep then R.step a = b
    else if tag = tagWit then if b = 0 then R.wit a else false
    else false

/-! ## A5. runOfAssign "propre" + théorèmes principaux Stage A -/

/-- Decode a run from a satisfying assignment using extracted values. -/
def runOfAssign'
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    (A : Assign)
    (_hA : Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1))
    : TableauRun :=
  { st   := fun t => stateOf A T M.numStates t
    hd   := fun t => headOf  A T S t
    tape := fun t k => tapeOf A T S M.numSymbols t k
    step := fun t => stepOf  A T M.numRules t
    wit  := fun i => A (varWit i) }

/-- Direction →: Sat A genTableauAll → ValidRun (runOfAssign' A). -/
theorem sat_genTableauAll_implies_validRun
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    {A : Assign}
    (hA : Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)) :
    ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1
      (runOfAssign' T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 A hA) := by
  sorry

/-- Direction ←: ValidRun R → Sat (assignOfRun R) genTableauAll. -/
theorem validRun_implies_sat_genTableauAll
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    {R : TableauRun}
    (hR : ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) :
    Sat (assignOfRun T S M R)
      (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) := by
  sorry

/-! ### Main Theorems Stage A -/

/-- Satisfiability via assignment ↔ existence of valid run. -/
theorem tableau_sat_assign_iff_exists_run
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    (∃ A : Assign, Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)) ↔
    (∃ R : TableauRun, ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) := by
  constructor
  · intro ⟨A, hA⟩
    exact ⟨runOfAssign' T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 A hA,
           sat_genTableauAll_implies_validRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 hA⟩
  · intro ⟨R, hR⟩
    exact ⟨assignOfRun T S M R,
           validRun_implies_sat_genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 hR⟩

/-- CNF.Satisfiable version (for SATBundle compatibility). -/
theorem tableau_satisfiable_iff_exists_run
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    CNF.Satisfiable (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) ↔
    (∃ R : TableauRun, ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) :=
  (satisfiable_iff_exists_sat_assign _).trans (tableau_sat_assign_iff_exists_run T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)

/-- Polynomial bound on maxVar for genTableauAll (for SATBundle wBound compatibility). -/
theorem maxVar_genTableauAll_le_poly
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    maxVar (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) + 1 ≤
      tableauFullSizeBoundFun M (T + S) := by
  sorry


end RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas
