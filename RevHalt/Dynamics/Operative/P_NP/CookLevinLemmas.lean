/-
  RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas

  Stage A: Pure SAT semantics of genTableauAll.
  This file proves that the CNF generated by `genTableauAll` is satisfiable
  if and only if there exists a valid TableauRun.
-/
import RevHalt.Dynamics.Operative.P_NP.CookLevinTableau
import RevHalt.Dynamics.Operative.P_NP.CookLevinGadgets
import RevHalt.Dynamics.Operative.P_NP.SAT
import RevHalt.Dynamics.Operative.P_NP.PNP
import Mathlib.Data.List.Range
import Mathlib.Tactic.Linarith

namespace RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas

open RevHalt
open RevHalt.Dynamics.Operative.P_NP.SAT
open RevHalt.Dynamics.Operative.P_NP.SAT.CNF
open RevHalt.Dynamics.Operative.P_NP.CookLevinGadgets
open RevHalt.Dynamics.Operative.P_NP.CookLevinTableau
open RevHalt.Dynamics.Operative.P_NP.PNP

abbrev Assign := CookLevinGadgets.Var → Bool

/-- Evaluate variable with function assignment. -/
def evalVar' (A : Assign) (v : CookLevinGadgets.Var) : Bool := A v

def evalLit' (A : Assign) (ℓ : CNF.Lit) : Bool :=
  let b := evalVar' A ℓ.v
  if ℓ.neg then !b else b

def evalClause' (A : Assign) (C : CNF.Clause) : Bool :=
  C.any (evalLit' A)

def evalCNF' (A : Assign) (F : CNF.CNF) : Bool :=
  F.all (evalClause' A)

/-- A variable assignment satisfies a formula. -/
def Sat (A : Assign) (F : CNF.CNF) : Prop := evalCNF' A F = true

/-! ### Gadget Lemmas (Pure Boolean Logic) -/

theorem sat_andCNF {A : Assign} {F G : CNF.CNF} :
    Sat A (andCNF F G) ↔ Sat A F ∧ Sat A G := by
  unfold Sat andCNF evalCNF'
  simp only [List.all_append, Bool.and_eq_true]

theorem sat_andCNFs {A : Assign} {Fs : List CNF.CNF} :
    Sat A (andCNFs Fs) ↔ ∀ F ∈ Fs, Sat A F := by
  unfold Sat andCNFs evalCNF'
  induction Fs with
  | nil =>
    simp only [List.flatten_nil, List.all_nil, List.not_mem_nil, false_implies, implies_true]
  | cons F Fs ih =>
    simp only [List.flatten_cons, List.all_append, Bool.and_eq_true, List.mem_cons,
               forall_eq_or_imp]
    exact and_congr Iff.rfl ih

theorem sat_impClause {A : Assign} {ante : List CNF.Lit} {cons : CNF.Lit} :
    Sat A [impClause ante cons] ↔
      ((∀ l ∈ ante, evalLit' A l = true) → evalLit' A cons = true) := by
  unfold Sat evalCNF' impClause
  simp only [List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_append,
             List.any_map, Bool.or_eq_true]
  -- Key lemma: evalLit' A (notLit l) = !evalLit' A l
  have evalNotLit : ∀ l, evalLit' A (notLit l) = !evalLit' A l := by
    intro l
    simp only [evalLit', notLit, evalVar']
    cases hl : l.neg <;> simp
  constructor
  · intro hOr hAnte
    rcases hOr with hNeg | hCons
    · -- Some negated literal is true → contradiction
      simp only [List.any_eq_true, Function.comp_apply] at hNeg
      rcases hNeg with ⟨l, hl_mem, hl_eval⟩
      rw [evalNotLit] at hl_eval
      have hAnte_l := hAnte l hl_mem
      simp only [Bool.not_eq_true'] at hl_eval
      simp_all
    · -- Consequent is true directly
      simp only [List.any_cons, List.any_nil, Bool.or_false] at hCons
      exact hCons
  · intro hImp
    by_cases hAll : ∀ l ∈ ante, evalLit' A l = true
    · right
      simp only [List.any_cons, List.any_nil, Bool.or_false]
      exact hImp hAll
    · left
      push_neg at hAll
      rcases hAll with ⟨l, hl_mem, hl_false⟩
      simp only [List.any_eq_true, Function.comp_apply]
      use l, hl_mem
      rw [evalNotLit]
      simp only [Bool.not_eq_true', Bool.eq_false_iff] at hl_false ⊢
      exact hl_false

theorem sat_atLeastOne {A : Assign} {lits : List CookLevinGadgets.Var} (h : lits ≠ []) :
    Sat A (atLeastOne lits) ↔ ∃ v ∈ lits, A v = true := by
  unfold Sat evalCNF' atLeastOne
  cases lits with
  | nil => contradiction
  | cons x xs =>
    simp only [List.all_cons, List.all_nil, Bool.and_true, evalClause',
               List.any_map, List.any_eq_true, Function.comp_apply]
    constructor
    · intro ⟨v, hv_mem, hv_eval⟩
      use v, hv_mem
      simp only [evalLit', pos, evalVar'] at hv_eval
      exact hv_eval
    · intro ⟨v, hv_mem, hv_true⟩
      use v, hv_mem
      simp only [evalLit', pos, evalVar']
      exact hv_true

/-! ## A0. Lemmes de base sur les clauses unitaires et disjonctions -/

theorem sat_unit_pos {A : Assign} {v : CookLevinGadgets.Var} :
    Sat A [[pos v]] ↔ A v = true := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_cons, List.any_nil, Bool.or_false, evalLit', pos, evalVar']
  cases A v <;> decide

theorem sat_unit_neg {A : Assign} {v : CookLevinGadgets.Var} :
    Sat A [[neg v]] ↔ A v = false := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_cons, List.any_nil, Bool.or_false, evalLit', neg, evalVar']
  cases A v <;> decide

theorem sat_bigOr_pos {A : Assign} {vs : List CookLevinGadgets.Var} :
    Sat A [vs.map pos] ↔ ∃ v ∈ vs, A v = true := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause']
  rw [List.any_map]
  simp only [evalLit', pos, evalVar', Function.comp_apply, List.any_eq_true]
  rfl

theorem sat_andCNFs_iff {A : Assign} {Fs : List CNF.CNF} :
    Sat A (andCNFs Fs) ↔ ∀ F ∈ Fs, Sat A F := by
  unfold andCNFs Sat evalCNF'
  rw [List.all_flatten, List.all_eq_true]

theorem mem_pairwise_subset {α} (l : List α) (x y : α) :
    (x, y) ∈ pairwise l → x ∈ l ∧ y ∈ l := by
  induction l with
  | nil => simp [pairwise]
  | cons h t ih =>
    intro H
    simp only [pairwise, List.mem_append, List.mem_map] at H
    cases H with
    | inl hmap =>
      rcases hmap with ⟨z, hz, heq⟩
      injection heq with hx hy
      subst hx; subst hy
      simp [hz]
    | inr hpair =>
      cases ih hpair with | intro ix iy =>
      simp [ix, iy]

theorem distinct_of_mem_pairwise {α} [DecidableEq α] (l : List α) (hl : l.Nodup) (x y : α) :
    (x, y) ∈ pairwise l → x ≠ y := by
  induction l with
  | nil => simp [pairwise]
  | cons h t ih =>
    rw [List.nodup_cons] at hl
    rcases hl with ⟨hnotin, htail⟩
    intro H
    simp only [pairwise, List.mem_append, List.mem_map] at H
    cases H with
    | inl hmap =>
      rcases hmap with ⟨z, hz, heq⟩
      injection heq with hx hy
      subst hx
      subst hy
      intro heq
      subst heq
      exact hnotin hz
    | inr hpair =>
      exact ih htail hpair

theorem exists_pair_of_mem_distinct {α} [DecidableEq α] (l : List α) (x y : α) :
    x ∈ l → y ∈ l → x ≠ y → (x, y) ∈ pairwise l ∨ (y, x) ∈ pairwise l := by
  induction l with
  | nil => simp
  | cons h t ih =>
    intro hx hy hne
    simp only [List.mem_cons] at hx hy
    simp only [pairwise, List.mem_append, List.mem_map]
    rcases hx with rfl | hxt
    · rcases hy with rfl | hyt
      · contradiction
      · left; left; use y;
    · rcases hy with rfl | hyt
      · right; left; use x;
      · rcases ih hxt hyt hne with h1 | h2
        · left; right; exact h1
        · right; right; exact h2

theorem sat_atMostOne {A : Assign} {lits : List CookLevinGadgets.Var} (hNd : lits.Nodup) :
    Sat A (atMostOne lits) ↔
      ∀ v ∈ lits, ∀ v' ∈ lits, v ≠ v' → ¬(A v = true ∧ A v' = true) := by
  simp only [Sat, evalCNF', atMostOne]
  rw [List.all_map, List.all_eq_true]
  simp only [Function.comp_apply]
  constructor
  · intro h v hv v' hv' hne
    cases exists_pair_of_mem_distinct lits v v' hv hv' hne with
    | inl hpair =>
      specialize h (v, v') hpair
      simp [evalClause', evalLit', neg, evalVar'] at h
      intro hAnd
      rw [hAnd.1, hAnd.2] at h
      simp at h
    | inr hpair =>
      specialize h (v', v) hpair
      simp [evalClause', evalLit', neg, evalVar'] at h
      intro hAnd
      rw [hAnd.1, hAnd.2] at h
      simp at h
  · intro H p hp
    have : p.1 ∈ lits ∧ p.2 ∈ lits := mem_pairwise_subset lits p.1 p.2 hp
    specialize H p.1 this.1 p.2 this.2 (distinct_of_mem_pairwise lits hNd p.1 p.2 hp)
    simp [evalClause', evalLit', neg, evalVar']
    cases h1 : A p.1 <;> cases h2 : A p.2 <;> simp [h1, h2] at H ⊢

theorem sat_andCNF_pair {A : Assign} {F G : CNF.CNF} : Sat A (andCNF F G) ↔ Sat A F ∧ Sat A G := by
  unfold andCNF Sat evalCNF'
  simp only [List.all_append, Bool.and_eq_true]

theorem sat_exactlyOne {A : Assign} {lits : List CookLevinGadgets.Var} (h : lits ≠ []) (hNd : lits.Nodup) :
    Sat A (exactlyOne lits) ↔
      (∃ v ∈ lits, A v = true) ∧
      (∀ v ∈ lits, ∀ v' ∈ lits, v ≠ v' → ¬(A v = true ∧ A v' = true)) := by
  unfold exactlyOne
  rw [sat_andCNF_pair]
  unfold atLeastOne
  split
  · contradiction
  · rw [sat_bigOr_pos, sat_atMostOne hNd]

/-! ### Assign ↔ Witness Bridge API -/

/-- Max variable index used by a literal. -/
def maxVarLit (ℓ : CNF.Lit) : ℕ := ℓ.v

/-- Max variable index used by a clause. -/
def maxVarClause (C : CNF.Clause) : ℕ :=
  C.foldl (fun acc ℓ => max acc (maxVarLit ℓ)) 0

/-- Max variable index used by a CNF formula. -/
def maxVar (F : CNF.CNF) : ℕ :=
  F.foldl (fun acc C => max acc (maxVarClause C)) 0

/-- Turn a PNP.Witness (List Bool) into an assignment function with default false. -/
def assignOfWitness (w : PNP.Witness) : Assign :=
  fun v => w.getD v false

/-- Turn an assignment function into a PNP.Witness list of length L. -/
def witnessOfAssign (L : ℕ) (A : Assign) : PNP.Witness :=
  (List.range L).map A

/-- Witness size of witnessOfAssign is exactly L. -/
theorem witnessOfAssign_size (L : ℕ) (A : Assign) :
    PNP.witnessSize (witnessOfAssign L A) = L := by
  unfold witnessOfAssign PNP.witnessSize
  simp only [List.length_map, List.length_range]

/-- assignOfWitness ∘ witnessOfAssign recovers A for indices < L. -/
theorem assignOfWitness_witnessOfAssign (L : ℕ) (A : Assign) (v : ℕ) (hv : v < L) :
    assignOfWitness (witnessOfAssign L A) v = A v := by
  dsimp [assignOfWitness, witnessOfAssign]
  -- Robust range append lemma
  have range_append : ∀ n, List.range (n + 1) = List.range n ++ [n] := by
    intro n
    induction n with
    | zero => rfl
    | succ n ih => rw [List.range_succ, ih]

  -- Main property using getD to avoid dependent type issues
  have map_range_getD : ∀ (n : ℕ) (i : ℕ), i < n → (List.map A (List.range n)).getD i false = A i := by
    intro n
    induction n with
    | zero => intro i h; contradiction
    | succ n ih =>
      intro i h_lt
      rw [range_append, List.map_append]
      simp only [List.map_cons, List.map_nil]

      have getD_append_lt : ∀ (l : List Bool) (x : Bool) (k : ℕ) (d : Bool), k < l.length → (l ++ [x]).getD k d = l.getD k d := by
        intro l x k d h
        induction l generalizing k with
        | nil => contradiction
        | cons h t ih =>
          cases k with
          | zero => rfl
          | succ k' => simp [List.getD]; apply ih; simp [List.length] at h; exact h

      have getD_append_eq : ∀ (l : List Bool) (x : Bool) (d : Bool), (l ++ [x]).getD l.length d = x := by
        intro l x d
        induction l with
        | nil => rfl
        | cons h t ih => simp [List.getD, List.length];

      if h : i < n then
        rw [getD_append_lt]
        · exact ih i h
        · simp [List.length_map, List.length_range]; exact h
      else
        have h_eq : i = n := by
          apply Nat.le_antisymm
          · apply Nat.le_of_lt_succ h_lt
          · apply Nat.le_of_not_lt h
        rw [h_eq]
        -- Goal: (map ... ++ [A n]).getD n false = A n
        have h_len : (List.map A (List.range n)).length = n := by simp [List.length_range]
        convert getD_append_eq (List.map A (List.range n)) (A n) false
        exact h_len.symm

  apply map_range_getD L v hv

/-- Monotonicity of foldl max. -/
theorem foldl_max_mono (l : List α) (f : α → ℕ) (init : ℕ) :
    init ≤ l.foldl (fun acc y => max acc (f y)) init := by
  induction l generalizing init with
  | nil => simp only [List.foldl_nil, Nat.le_refl]
  | cons h t ih =>
    simp only [List.foldl_cons]
    apply Nat.le_trans (Nat.le_max_left _ _) (ih _)

/-- Helper for maxVar bound found in folds. -/
theorem foldl_max_le {l : List α} {f : α → ℕ} {init : ℕ} (x : α) (hx : x ∈ l) :
    f x ≤ l.foldl (fun acc y => max acc (f y)) init := by
  induction l generalizing init with
  | nil => contradiction
  | cons head tail ih =>
    simp only [List.foldl_cons, List.mem_cons] at hx ⊢
    cases hx with
    | inl h_eq =>
      subst h_eq
      apply Nat.le_trans (m := max init (f x))
      · apply Nat.le_max_right
      · apply foldl_max_mono
    | inr h_in =>
      apply ih (init := max init (f head))
      exact h_in

theorem maxVar_bound (F : CNF.CNF) :
    ∀ C ∈ F, ∀ ℓ ∈ C, ℓ.v ≤ maxVar F := by
  intro C hC ℓ hℓ
  unfold maxVar
  have hC_le := foldl_max_le (f := maxVarClause) C hC (init := 0)
  apply Nat.le_trans _ hC_le
  unfold maxVarClause
  exact foldl_max_le (f := maxVarLit) ℓ hℓ (init := 0)

/-- If all vars in F are < maxVar F + 1, then Sat via assignment ↔ evalCNF via padded witness. -/
theorem sat_iff_evalCNF_witness (A : Assign) (F : CNF.CNF) :
    Sat A F ↔ CNF.evalCNF (witnessOfAssign (maxVar F + 1) A) F = true := by
  have sat_iff_eval_of_bound : ∀ L, maxVar F < L → (Sat A F ↔ CNF.evalCNF (witnessOfAssign L A) F = true) := by
    intro L hL
    rw [Sat, evalCNF', CNF.evalCNF]
    simp only [List.all_eq_true, List.any_eq_true, evalClause', CNF.evalClause, evalLit', CNF.evalLit, CNF.evalVar]
    apply forall_congr'
    intro C
    apply imp_congr_right
    intro hC
    apply exists_congr
    intro ℓ
    apply and_congr_right
    intro hℓ
    -- Goal: A ℓ.v ... ↔ witness ... ℓ.v ...
    have hv : ℓ.v < L := Nat.lt_of_le_of_lt (maxVar_bound F C hC ℓ hℓ) hL
    have h_rw : (witnessOfAssign L A).getD ℓ.v false = A ℓ.v := assignOfWitness_witnessOfAssign L A ℓ.v hv
    rw [h_rw]
    rfl

  exact sat_iff_eval_of_bound (maxVar F + 1) (Nat.lt_succ_self _)

/-- Bridge: satisfiable via assignment ↔ satisfiable via bounded PNP.Witness. -/
theorem sat_assign_iff_sat_witness (F : CNF.CNF) :
    (∃ A : Assign, Sat A F) ↔
    (∃ w : PNP.Witness, PNP.witnessSize w ≤ (maxVar F + 1) ∧ CNF.evalCNF w F = true) := by
  constructor
  · rintro ⟨A, hA⟩
    use witnessOfAssign (maxVar F + 1) A
    constructor
    · rw [witnessOfAssign_size]
    · rw [← sat_iff_evalCNF_witness]
      exact hA
  · rintro ⟨w, _, hw⟩
    use assignOfWitness w
    unfold Sat evalCNF'
    unfold CNF.evalCNF at hw
    simp only [List.all_eq_true]
    intro C hC
    simp only [List.all_eq_true] at hw
    specialize hw C hC
    simp only [evalClause', List.any_eq_true]
    simp only [CNF.evalClause, List.any_eq_true] at hw
    obtain ⟨ℓ, hℓ, hl_true⟩ := hw
    use ℓ, hℓ
    simp only [evalLit']
    exact hl_true

/-- Equivalence between witness-based and assignment-based satisfiability. -/
theorem satisfiable_iff_exists_sat_assign (F : CNF.CNF) :
    CNF.Satisfiable F ↔ ∃ A : Assign, Sat A F := by
  constructor
  · rintro ⟨w, hw⟩
    use assignOfWitness w
    -- They are definitionally equal check?
    -- Sat (assignOfWitness w) F := evalCNF' (assignOfWitness w) F = true
    -- evalCNF w F = true
    -- Let's check definitions logic.
    -- evalVar' (assignOfWitness w) v = (assignOfWitness w) v = w.getD v false
    -- CNF.evalVar w v = w.getD v false
    -- So they are equal.
    convert hw
  · rintro ⟨A, hA⟩
    rw [sat_iff_evalCNF_witness] at hA
    exact ⟨_, hA⟩

/-- Bridge to SATBundle: if maxVar + 1 fits in wBound, we get the right form. -/
theorem satisfiable_bounded_iff_satisfiable
    (wBound : ℕ) (F : CNF.CNF)
    (h : maxVar F + 1 ≤ wBound) :
    CNF.Satisfiable F ↔
      (∃ w : PNP.Witness, PNP.witnessSize w ≤ wBound ∧ CNF.evalCNF w F = true) := by
  constructor
  · intro hSat
    -- Satisfiable -> ∃ A, Sat A F
    rcases (satisfiable_iff_exists_sat_assign (F := F)).1 hSat with ⟨A, hA⟩
    -- ∃ A, Sat A F -> bounded witness (≤ maxVar+1)
    rcases (sat_assign_iff_sat_witness (F := F)).1 ⟨A, hA⟩ with ⟨w, hwSize, hwEval⟩
    refine ⟨w, Nat.le_trans hwSize h, hwEval⟩
  · rintro ⟨w, _, hwEval⟩
    exact ⟨w, hwEval⟩



/-! ## A1. Décomposition de genTableauAll en conjonction de composants -/

theorem sat_genTableauAll_iff
    {A : Assign} (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) ↔
      Sat A (uniqueState T M.numStates) ∧
      Sat A (uniqueHead  T S) ∧
      Sat A (uniqueTape  T S M.numSymbols) ∧
      Sat A (uniqueStep  T M.numRules) ∧
      Sat A (genTransition T S M) ∧
      Sat A (genInertia   T S M.numSymbols) ∧
      Sat A (genInitConst S q0 head0 tape0 witOff witLen) ∧
      Sat A (genInitWitness witLen witOff sym0 sym1) ∧
      Sat A (genAccept T qAcc) := by
  unfold genTableauAll
  rw [sat_andCNFs_iff]
  constructor
  · intro h
    simp only [List.mem_cons] at h
    repeat' constructor
    all_goals apply h; simp
  · intro h F hF
    simp only [List.mem_cons] at hF
    rcases h with ⟨h1, h2, h3, h4, h5, h6, h7, h8, h9⟩
    rcases hF with rfl | rfl | rfl | rfl | rfl | rfl | rfl | rfl | rfl | hFalse
    · exact h1
    · exact h2
    · exact h3
    · exact h4
    · exact h5
    · exact h6
    · exact h7
    · exact h8
    · exact h9
    · cases hFalse

/-! ## A2. Extraction "uniqueState/head/tape/step" depuis Sat -/

/-- Extract the unique state at time t from a satisfying assignment. -/
def stateOf (A : Assign) (_T numStates : ℕ) (t : ℕ) : ℕ :=
  ((List.range numStates).find? (fun q => A (varState t q))).getD 0


private
theorem find?_one_mem_pred {α : Type} {p : α → Bool} {l : List α} {d : α}
    (h : ∃ x ∈ l, p x = true) :
    let res := (l.find? p).getD d
    res ∈ l ∧ p res = true := by
  induction l with
  | nil =>
    rcases h with ⟨_, hfalse, _⟩
    contradiction
  | cons a l ih =>
    dsimp [List.find?]
    split
    next hpa =>
      simp only [Option.getD_some]
      constructor
      · apply List.mem_cons_self
      · exact hpa
    next hpa_false =>
    next hpa_false =>
      rcases h with ⟨x, hx_mem, hx_p⟩
      simp only [List.mem_cons] at hx_mem
      have h_tail : ∃ x ∈ l, p x = true := by
        rcases hx_mem with rfl | hx_mem_tail
        · rw [hx_p] at hpa_false; contradiction
        · exact ⟨x, hx_mem_tail, hx_p⟩
      specialize ih h_tail
      constructor
      · exact List.mem_cons_of_mem _ ih.1
      · exact ih.2

private theorem var_inj_helper (t tag : ℕ) :
    Function.Injective (fun x => mkVar tag t x 0) := by
  intro x y h
  simp only [mkVar, Nat.pair_eq_pair] at h
  rcases h with ⟨_, h2⟩
  rcases h2 with ⟨_, h3⟩
  rcases h3 with ⟨res, _⟩
  exact res

private theorem varState_inj (t : ℕ) : Function.Injective (fun q => varState t q) :=
  var_inj_helper t tagState

private def stateVars (t numStates : ℕ) : List CookLevinGadgets.Var :=
  (List.range numStates).map (fun q => varState t q)

private theorem stateVars_nodup (t numStates : ℕ) :
    (stateVars t numStates).Nodup :=
  List.Nodup.map (varState_inj t) List.nodup_range

theorem stateOf_spec
    {A : Assign} {T numStates t : ℕ}
    (hU : Sat A (uniqueState T numStates)) (ht : t ≤ T)
    (hNum : numStates > 0) :
    stateOf A T numStates t < numStates ∧
    A (varState t (stateOf A T numStates t)) = true ∧
    (∀ q < numStates, q ≠ stateOf A T numStates t → A (varState t q) = false) := by
  change Sat A (andCNFs ((List.range (T + 1)).map (fun t => exactlyOne (stateVars t numStates)))) at hU
  rw [sat_andCNFs_iff] at hU
  have hEx1 : Sat A (exactlyOne (stateVars t numStates)) := by
    apply hU
    simp only [List.mem_map, List.mem_range]
    exact ⟨t, Nat.lt_succ_of_le ht, rfl⟩

  let vars := stateVars t numStates
  have hNe : vars ≠ [] := by
    intro hEmpty
    dsimp [vars] at hEmpty
    rw [stateVars] at hEmpty
    simp at hEmpty
    linarith

  have hNd : vars.Nodup := stateVars_nodup t numStates
  have hSat := (sat_exactlyOne hNe hNd).mp hEx1
  obtain ⟨hAtLeastOne, hAtMostOne⟩ := hSat

  have hExists : ∃ q, q ∈ List.range numStates ∧ A (varState t q) = true := by
    rcases hAtLeastOne with ⟨v, hvMem, hvTrue⟩
    change v ∈ (List.range numStates).map (varState t) at hvMem
    rw [List.mem_map] at hvMem
    rcases hvMem with ⟨q, hqMem, rfl⟩
    exact ⟨q, hqMem, hvTrue⟩

  let q0 := stateOf A T numStates t
  have hFind : q0 ∈ List.range numStates ∧ A (varState t q0) = true := by
    dsimp [stateOf]
    apply find?_one_mem_pred hExists

  refine ⟨List.mem_range.mp hFind.1, hFind.2, ?_⟩
  intro q hqLt hqNe
  by_contra hContra
  simp only [Bool.not_eq_false] at hContra
  apply hAtMostOne (varState t q) _ (varState t q0) _ _ ⟨hContra, hFind.2⟩
  · change varState t q ∈ (List.range numStates).map (varState t)
    rw [List.mem_map]
    use q
    constructor
    · rw [List.mem_range]; exact hqLt
    · rfl
  · change varState t q0 ∈ (List.range numStates).map (varState t)
    rw [List.mem_map]
    use q0
    constructor
    · exact hFind.1
    · rfl
  · intro hEq; apply hqNe; exact varState_inj t hEq
/-- Extract the unique head position at time t from a satisfying assignment. -/
def headOf (A : Assign) (_T S : ℕ) (t : ℕ) : ℕ :=
  ((List.range S).find? (fun k => A (varHead t k))).getD 0


private theorem varHead_inj (t : ℕ) : Function.Injective (fun k => varHead t k) :=
  var_inj_helper t tagHead

private def headVars (t S : ℕ) : List CookLevinGadgets.Var :=
  (List.range S).map (fun k => varHead t k)

private theorem headVars_nodup (t S : ℕ) : (headVars t S).Nodup :=
  List.Nodup.map (varHead_inj t) List.nodup_range

theorem headOf_spec
    {A : Assign} {T S t : ℕ}
    (hU : Sat A (uniqueHead T S)) (ht : t ≤ T) (hS : S > 0) :
    headOf A T S t < S ∧
    A (varHead t (headOf A T S t)) = true ∧
    (∀ k < S, k ≠ headOf A T S t → A (varHead t k) = false) := by
  change Sat A (andCNFs ((List.range (T + 1)).map (fun t => exactlyOne (headVars t S)))) at hU
  rw [sat_andCNFs_iff] at hU
  have hEx1 : Sat A (exactlyOne (headVars t S)) := by
    apply hU
    simp only [List.mem_map, List.mem_range]
    exact ⟨t, Nat.lt_succ_of_le ht, rfl⟩

  let vars := headVars t S
  have hNe : vars ≠ [] := by
    intro hEmpty
    dsimp [vars] at hEmpty
    rw [headVars] at hEmpty
    simp at hEmpty
    linarith

  have hNd : vars.Nodup := headVars_nodup t S
  have hSat := (sat_exactlyOne hNe hNd).mp hEx1
  obtain ⟨hAtLeastOne, hAtMostOne⟩ := hSat

  have hExists : ∃ k, k ∈ List.range S ∧ A (varHead t k) = true := by
    rcases hAtLeastOne with ⟨v, hvMem, hvTrue⟩
    change v ∈ (List.range S).map (varHead t) at hvMem
    rw [List.mem_map] at hvMem
    rcases hvMem with ⟨k, hkMem, rfl⟩
    exact ⟨k, hkMem, hvTrue⟩

  let k0 := headOf A T S t
  have hFind : k0 ∈ List.range S ∧ A (varHead t k0) = true := by
    dsimp [headOf]
    apply find?_one_mem_pred hExists

  refine ⟨List.mem_range.mp hFind.1, hFind.2, ?_⟩
  intro k hkLt hkNe
  by_contra hContra
  simp only [Bool.not_eq_false] at hContra
  apply hAtMostOne (varHead t k) _ (varHead t k0) _ _ ⟨hContra, hFind.2⟩
  · change varHead t k ∈ (List.range S).map (varHead t)
    rw [List.mem_map]
    use k
    constructor
    · rw [List.mem_range]; exact hkLt
    · rfl
  · change varHead t k0 ∈ (List.range S).map (varHead t)
    rw [List.mem_map]
    use k0
    constructor
    · exact hFind.1
    · rfl
  · intro hEq; apply hkNe; exact varHead_inj t hEq/-- Extract the unique tape symbol at (t, k) from a satisfying assignment. -/
def tapeOf (A : Assign) (_T _S numSymbols : ℕ) (t k : ℕ) : ℕ :=
  ((List.range numSymbols).find? (fun s => A (varTape t k s))).getD 0


private theorem varTape_inj (t k : ℕ) : Function.Injective (fun s => varTape t k s) := by
  intro s s' h
  simp only [varTape, mkVar, Nat.pair_eq_pair] at h
  rcases h with ⟨_, h2⟩
  rcases h2 with ⟨_, h3⟩
  rcases h3 with ⟨_, h4⟩
  exact h4

private def tapeVars (t k numSymbols : ℕ) : List CookLevinGadgets.Var :=
  (List.range numSymbols).map (fun s => varTape t k s)

private theorem tapeVars_nodup (t k numSymbols : ℕ) : (tapeVars t k numSymbols).Nodup :=
  List.Nodup.map (varTape_inj t k) List.nodup_range

theorem tapeOf_spec
    {A : Assign} {T S numSymbols t k : ℕ}
    (hU : Sat A (uniqueTape T S numSymbols)) (ht : t ≤ T) (hk : k < S)
    (hSym : numSymbols > 0) :
    tapeOf A T S numSymbols t k < numSymbols ∧
    A (varTape t k (tapeOf A T S numSymbols t k)) = true ∧
    (∀ s < numSymbols, s ≠ tapeOf A T S numSymbols t k → A (varTape t k s) = false) := by
  change Sat A (andCNFs ((List.range (T + 1)).map (fun t => (List.range S).flatMap (fun k => exactlyOne (tapeVars t k numSymbols))))) at hU
  rw [sat_andCNFs_iff] at hU
  have hSatBig : Sat A ((List.range S).flatMap (fun k => exactlyOne (tapeVars t k numSymbols))) := by
    apply hU
    simp only [List.mem_map, List.mem_range]
    use t
    constructor
    · apply Nat.lt_succ_of_le ht
    · rfl
  change Sat A (andCNFs ((List.range S).map (fun k => exactlyOne (tapeVars t k numSymbols)))) at hSatBig
  rw [sat_andCNFs_iff] at hSatBig
  have hEx1 : Sat A (exactlyOne (tapeVars t k numSymbols)) := by
    apply hSatBig
    simp only [List.mem_map, List.mem_range]
    use k

  let vars := tapeVars t k numSymbols
  have hNe : vars ≠ [] := by
    intro hEmpty
    dsimp [vars] at hEmpty
    rw [tapeVars] at hEmpty
    simp at hEmpty
    linarith

  have hNd : vars.Nodup := tapeVars_nodup t k numSymbols
  have hSat := (sat_exactlyOne hNe hNd).mp hEx1
  obtain ⟨hAtLeastOne, hAtMostOne⟩ := hSat

  have hExists : ∃ s, s ∈ List.range numSymbols ∧ A (varTape t k s) = true := by
    rcases hAtLeastOne with ⟨v, hvMem, hvTrue⟩
    change v ∈ (List.range numSymbols).map (varTape t k) at hvMem
    rw [List.mem_map] at hvMem
    rcases hvMem with ⟨s, hsMem, rfl⟩
    exact ⟨s, hsMem, hvTrue⟩

  let s0 := tapeOf A T S numSymbols t k
  have hFind : s0 ∈ List.range numSymbols ∧ A (varTape t k s0) = true := by
    dsimp [tapeOf]
    apply find?_one_mem_pred hExists

  refine ⟨List.mem_range.mp hFind.1, hFind.2, ?_⟩
  intro s hsLt hsNe
  by_contra hContra
  simp only [Bool.not_eq_false] at hContra
  apply hAtMostOne (varTape t k s) _ (varTape t k s0) _ _ ⟨hContra, hFind.2⟩
  · change varTape t k s ∈ (List.range numSymbols).map (varTape t k)
    rw [List.mem_map]
    use s
    constructor
    · rw [List.mem_range]; exact hsLt
    · rfl
  · change varTape t k s0 ∈ (List.range numSymbols).map (varTape t k)
    rw [List.mem_map]
    use s0
    constructor
    · exact hFind.1
    · rfl
  · intro hEq; apply hsNe; exact varTape_inj t k hEq

/-! ### Helper lemmas: if a specific variable is true, then xOf equals that value -/

private theorem eq_stateOf_of_true
    {A : Assign} {T numStates t q : ℕ}
    (hU : Sat A (uniqueState T numStates)) (ht : t ≤ T) (hPos : numStates > 0)
    (hq : q < numStates)
    (hqTrue : A (varState t q) = true) :
    stateOf A T numStates t = q := by
  have hs := stateOf_spec hU ht hPos
  by_contra hne
  have hfalse := hs.2.2 q hq (Ne.symm hne)
  simp_all

private theorem eq_headOf_of_true
    {A : Assign} {T S t k : ℕ}
    (hU : Sat A (uniqueHead T S)) (ht : t ≤ T) (hPos : S > 0)
    (hk : k < S)
    (hkTrue : A (varHead t k) = true) :
    headOf A T S t = k := by
  have hh := headOf_spec hU ht hPos
  by_contra hne
  have hfalse := hh.2.2 k hk (Ne.symm hne)
  simp_all

private theorem eq_tapeOf_of_true
    {A : Assign} {T S numSymbols t k s : ℕ}
    (hU : Sat A (uniqueTape T S numSymbols)) (ht : t ≤ T) (hk : k < S) (hPos : numSymbols > 0)
    (hs : s < numSymbols)
    (hsTrue : A (varTape t k s) = true) :
    tapeOf A T S numSymbols t k = s := by
  have htape := tapeOf_spec hU ht hk hPos
  by_contra hne
  have hfalse := htape.2.2 s hs (Ne.symm hne)
  simp_all

/-- Extract the unique step/rule index at time t from a satisfying assignment. -/
def stepOf (A : Assign) (_T numRules : ℕ) (t : ℕ) : ℕ :=
  ((List.range numRules).find? (fun r => A (varStep t r))).getD 0


private theorem varStep_inj (t : ℕ) : Function.Injective (fun r => varStep t r) :=
  var_inj_helper t tagStep

private def stepVars (t numRules : ℕ) : List CookLevinGadgets.Var :=
  (List.range numRules).map (fun r => varStep t r)

private theorem stepVars_nodup (t numRules : ℕ) : (stepVars t numRules).Nodup :=
  List.Nodup.map (varStep_inj t) List.nodup_range

theorem stepOf_spec
    {A : Assign} {T numRules t : ℕ}
    (hU : Sat A (uniqueStep T numRules)) (ht : t < T)
    (hRules : numRules > 0) :
    stepOf A T numRules t < numRules ∧
    A (varStep t (stepOf A T numRules t)) = true ∧
    (∀ r < numRules, r ≠ stepOf A T numRules t → A (varStep t r) = false) := by
  change Sat A (andCNFs ((List.range T).map (fun t => exactlyOne (stepVars t numRules)))) at hU
  rw [sat_andCNFs_iff] at hU
  have hEx1 : Sat A (exactlyOne (stepVars t numRules)) := by
    apply hU
    simp only [List.mem_map, List.mem_range]
    exact ⟨t, ht, rfl⟩

  let vars := stepVars t numRules
  have hNe : vars ≠ [] := by
    intro hEmpty
    dsimp [vars] at hEmpty
    simp only [stepVars] at hEmpty
    simp at hEmpty
    linarith

  have hNd : vars.Nodup := stepVars_nodup t numRules
  have hSat := (sat_exactlyOne hNe hNd).mp hEx1
  obtain ⟨hAtLeastOne, hAtMostOne⟩ := hSat

  have hExists : ∃ r, r ∈ List.range numRules ∧ A (varStep t r) = true := by
    rcases hAtLeastOne with ⟨v, hvMem, hvTrue⟩
    simp [vars] at hvMem
    simp only [stepVars] at hvMem
    rw [List.mem_map (f := fun r => varStep t r)] at hvMem
    rcases hvMem with ⟨r, hrMem, rfl⟩
    exact ⟨r, hrMem, hvTrue⟩

  let r0 := stepOf A T numRules t
  have hFind : r0 ∈ List.range numRules ∧ A (varStep t r0) = true := by
    dsimp [stepOf]
    apply find?_one_mem_pred hExists

  refine ⟨List.mem_range.mp hFind.1, hFind.2, ?_⟩
  intro r hrLt hrNe
  by_contra hContra
  simp only [Bool.not_eq_false] at hContra
  apply hAtMostOne (varStep t r) _ (varStep t r0) _ _ ⟨hContra, hFind.2⟩
  · change varStep t r ∈ (List.range numRules).map (varStep t)
    rw [List.mem_map]
    use r
    constructor
    · rw [List.mem_range]; exact hrLt
    · rfl
  · change varStep t r0 ∈ (List.range numRules).map (varStep t)
    rw [List.mem_map]
    use r0
    constructor
    · exact hFind.1
    · rfl
  · intro hEq; apply hrNe; exact varStep_inj t hEq/-! ## A3. Init / Witness / Accept sous forme "logique" -/

theorem sat_genInitConst_iff
    {A : Assign} (S q0 head0 : ℕ) (tape0 : ℕ → ℕ) (witOff witLen : ℕ) :
    Sat A (genInitConst S q0 head0 tape0 witOff witLen) ↔
      A (varState 0 q0) = true ∧
      A (varHead  0 head0) = true ∧
      (∀ k < S, (k < witOff ∨ k ≥ witOff + witLen) → A (varTape 0 k (tape0 k)) = true) := by
  unfold genInitConst
  dsimp only [CookLevinGadgets.pos, CNF.Lit.neg]
  simp [Sat, evalCNF', evalClause', evalLit', evalVar', List.all_eq_true]
  intros
  apply forall_congr'; intro k
  apply forall_congr'; intro hkS
  rw [imp_iff_not_or]
  simp [not_or, not_lt, not_le]

theorem sat_genInitWitness_iff
    {A : Assign} (witLen witOff sym0 sym1 : ℕ) :
    Sat A (genInitWitness witLen witOff sym0 sym1) ↔
      ∀ i < witLen,
        (A (varWit i) = true  → A (varTape 0 (witOff + i) sym1) = true) ∧
        (A (varWit i) = false → A (varTape 0 (witOff + i) sym0) = true) := by

  unfold genInitWitness
  simp only [Sat, evalCNF', List.all_eq_true]
  simp only [List.mem_flatMap, forall_exists_index, and_imp, List.mem_range]
  rw [forall_comm]
  apply forall_congr'; intro i
  constructor
  · -- Forward direction: Sat → semantic property
    intro h hi
    constructor
    · -- A (varWit i) = true → A (varTape 0 (witOff + i) sym1) = true
      intro hw
      have mem : impClause [pos (varWit i)] (pos (varTape 0 (witOff + i) sym1)) ∈
        [impClause [pos (varWit i)] (pos (varTape 0 (witOff + i) sym1)),
         impClause [neg (varWit i)] (pos (varTape 0 (witOff + i) sym0))] := by simp
      specialize h _ hi mem
      simp only [impClause, evalClause', List.any_eq_true, List.mem_append, List.mem_map,
                 List.mem_singleton, notLit, pos, evalLit', evalVar'] at h
      rcases h with ⟨lit, hMem, hEval⟩
      rcases hMem with ⟨orig, rfl, rfl⟩ | rfl
      · simp_all
      · simp_all
    · -- A (varWit i) = false → A (varTape 0 (witOff + i) sym0) = true
      intro hw
      have mem : impClause [neg (varWit i)] (pos (varTape 0 (witOff + i) sym0)) ∈
        [impClause [pos (varWit i)] (pos (varTape 0 (witOff + i) sym1)),
         impClause [neg (varWit i)] (pos (varTape 0 (witOff + i) sym0))] := by simp
      specialize h _ hi mem
      simp only [impClause, evalClause', List.any_eq_true, List.mem_append, List.mem_map,
                 List.mem_singleton, notLit, neg, evalLit', evalVar'] at h
      rcases h with ⟨lit, hMem, hEval⟩
      rcases hMem with ⟨orig, rfl, rfl⟩ | rfl
      · simp_all
      · simp only [pos] at hEval; simp_all
  · -- Backward direction
    intro h x hi hx
    specialize h hi
    rcases h with ⟨h1, h2⟩
    simp at hx
    rcases hx with rfl | rfl
    · dsimp [impClause, evalClause', evalLit', evalVar', CNF.Lit.neg, CookLevinGadgets.pos]
      rw [imp_iff_not_or] at h1
      simpa [Bool.or_eq_true] using h1
    · dsimp [impClause, evalClause', evalLit', evalVar', CNF.Lit.neg, CookLevinGadgets.pos, CookLevinGadgets.neg]
      rw [imp_iff_not_or] at h2
      simpa [Bool.or_eq_true] using h2

theorem sat_genAccept_iff
    {A : Assign} (T qAcc : ℕ) :
    Sat A (genAccept T qAcc) ↔ ∃ t ≤ T, A (varState t qAcc) = true := by
  unfold genAccept
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause']
  rw [List.any_map]
  simp only [List.any_eq_true, List.mem_range, Function.comp_apply]
  dsimp only [evalLit', evalVar', CookLevinGadgets.pos]
  constructor
  · intro ⟨t, ht, hVal⟩
    exact ⟨t, Nat.le_of_lt_succ ht, hVal⟩
  · intro ⟨t, ht, hVal⟩
    exact ⟨t, Nat.lt_succ_of_le ht, hVal⟩

/-! ## A4. Transition & inertie : lemmes locaux "stepCNF" puis globaux -/

theorem sat_stepCNF_implies
    {A : Assign} (S t k rId : ℕ) (R : TransitionRule) :
    Sat A (stepCNF S t k rId R) →
    (A (varStep t rId) = true ∧ A (varHead t k) = true) →
      A (varState t R.q) = true ∧
      A (varTape  t k R.s) = true ∧
      A (varState (t+1) R.q') = true ∧
      A (varTape  (t+1) k R.s') = true ∧
      A (varHead  (t+1) (movePos R.mv k)) = true := by
  intro hSat ⟨hStep, hHead⟩
  -- stepCNF = stepBoundary ++ stepGuard ++ stepEffect
  rw [stepCNF, Sat, evalCNF', List.all_append, List.all_append, Bool.and_eq_true, Bool.and_eq_true] at hSat
  obtain ⟨⟨_, hGuard⟩, hEffect⟩ := hSat
  -- Extract from stepGuard: two implication clauses
  simp only [stepGuard, List.all_cons, List.all_nil, Bool.and_true, Bool.and_eq_true] at hGuard
  obtain ⟨hStateGuard, hTapeGuard⟩ := hGuard
  -- Extract from stepEffect: three implication clauses
  simp only [stepEffect, List.all_cons, List.all_nil, Bool.and_true, Bool.and_eq_true] at hEffect
  obtain ⟨hStateEff, hTapeEff, hHeadEff⟩ := hEffect
  -- Simplify all clauses
  simp only [impClause, evalClause', List.any_eq_true, List.mem_append, List.mem_map,
             notLit, pos, evalLit', evalVar', List.mem_cons, List.mem_nil_iff,
             or_false] at hStateGuard hTapeGuard hStateEff hTapeEff hHeadEff
  -- Goal 1: A (varState t R.q) = true
  have h1 : A (varState t R.q) = true := by
    obtain ⟨x, hMem, hEval⟩ := hStateGuard
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- Goal 2: A (varTape t k R.s) = true
  have h2 : A (varTape t k R.s) = true := by
    obtain ⟨x, hMem, hEval⟩ := hTapeGuard
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- Goal 3: A (varState (t+1) R.q') = true
  have h3 : A (varState (t+1) R.q') = true := by
    obtain ⟨x, hMem, hEval⟩ := hStateEff
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl | rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- Goal 4: A (varTape (t+1) k R.s') = true
  have h4 : A (varTape (t+1) k R.s') = true := by
    obtain ⟨x, hMem, hEval⟩ := hTapeEff
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl | rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- Goal 5: A (varHead (t+1) (movePos R.mv k)) = true
  have h5 : A (varHead (t+1) (movePos R.mv k)) = true := by
    obtain ⟨x, hMem, hEval⟩ := hHeadEff
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl | rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  exact ⟨h1, h2, h3, h4, h5⟩

/-! ### Helper lemmas for Move.R bound via stepBoundary -/

private theorem sat_boundary_clause_forbids
    {A : Assign} {t k rId : ℕ} :
    Sat A [[neg (varStep t rId), neg (varHead t k)]] →
    (A (varStep t rId) = true ∧ A (varHead t k) = true) → False := by
  intro hSat hk
  have hcl : evalClause' A [neg (varStep t rId), neg (varHead t k)] = true := by
    simpa [Sat, evalCNF', evalClause'] using hSat
  have hor : (!A (varStep t rId) || !A (varHead t k)) = true := by
    simpa [evalClause', evalLit', evalVar'] using hcl
  have : false = true := by
    simp [hk.1, hk.2] at hor
  cases this

private theorem sat_stepCNF_implies_movePos_lt
    {A : Assign} (S t k rId : ℕ) (R : TransitionRule)
    (hSpos : S > 0) (hkLtS : k < S) :
    Sat A (stepCNF S t k rId R) →
    (A (varStep t rId) = true ∧ A (varHead t k) = true) →
    movePos R.mv k < S := by
  intro hSat hk
  cases hmv : R.mv with
  | L =>
      have : Nat.pred k < S := Nat.lt_of_le_of_lt (Nat.pred_le k) hkLtS
      simpa [movePos, hmv] using this
  | S =>
      simpa [movePos, hmv] using hkLtS
  | R =>
      have hSat' := hSat
      rw [stepCNF, Sat, evalCNF', List.all_append, List.all_append,
          Bool.and_eq_true, Bool.and_eq_true] at hSat'
      obtain ⟨⟨hBdry, _hGuard⟩, _hEff⟩ := hSat'
      have hBdrySat : Sat A (stepBoundary S t k rId R) := by
        rw [Sat, evalCNF']
        exact hBdry
      have hk_ne : k ≠ Nat.pred S := by
        intro hkEq
        have hSB :
            stepBoundary S t k rId R =
              [[neg (varStep t rId), neg (varHead t k)]] := by
          simp [stepBoundary, hmv, hkEq]
        have hClause : Sat A [[neg (varStep t rId), neg (varHead t k)]] := by
          rw [← hSB]; exact hBdrySat
        exact sat_boundary_clause_forbids (A := A) (t := t) (k := k) (rId := rId) hClause hk
      have hSpos' : 0 < S := hSpos
      have hSuccPred : Nat.succ (Nat.pred S) = S :=
        Nat.succ_pred_eq_of_pos hSpos'
      have hk_le_pred : k ≤ Nat.pred S := by
        have hLt : k < Nat.succ (Nat.pred S) := by
          rw [hSuccPred]; exact hkLtS
        exact Nat.lt_succ_iff.mp hLt
      have hk_lt_pred : k < Nat.pred S :=
        lt_of_le_of_ne hk_le_pred hk_ne
      have hk1_le_pred : k + 1 ≤ Nat.pred S :=
        Nat.succ_le_of_lt hk_lt_pred
      have hpred_lt : Nat.pred S < S :=
        Nat.pred_lt (Nat.ne_of_gt hSpos)
      have hk1_lt : k + 1 < S :=
        Nat.lt_of_le_of_lt hk1_le_pred hpred_lt
      simp only [movePos]
      exact hk1_lt

theorem sat_genTransition_implies_step_valid
    {A : Assign} (T S : ℕ) (M : TableauMachine)
    (hUst : Sat A (uniqueState T M.numStates))
    (hUhd : Sat A (uniqueHead  T S))
    (hUtp : Sat A (uniqueTape  T S M.numSymbols))
    (hUsp : Sat A (uniqueStep  T M.rules.length))
    (hR   : M.rules.length > 0)
    (hS   : S > 0)
    (hNst : M.numStates > 0)
    (hNsy : M.numSymbols > 0)
    -- Validity of transition rules (all q, s, q', s' are in bounds)
    (hRulesValid : ∀ i : Fin M.rules.length,
        (M.rules.get i).q < M.numStates ∧
        (M.rules.get i).s < M.numSymbols ∧
        (M.rules.get i).q' < M.numStates ∧
        (M.rules.get i).s' < M.numSymbols)
    (hTr  : Sat A (genTransition T S M)) :
    ∀ t, (ht : t < T) →
      let rId := stepOf A T M.rules.length t
      let k   := headOf A T S t
      let r   := M.rules.get ⟨rId, (stepOf_spec hUsp ht hR).1⟩
      (stateOf A T M.numStates t = r.q) ∧
      (tapeOf A T S M.numSymbols t k = r.s) ∧
      (stateOf A T M.numStates (t+1) = r.q') ∧
      (tapeOf A T S M.numSymbols (t+1) k = r.s') ∧
      (headOf A T S (t+1) = movePos r.mv k) := by
  intro t ht
  -- Get the rule index and head position
  let rId := stepOf A T M.rules.length t
  let k   := headOf A T S t
  let rIdx : Fin M.rules.length := ⟨rId, (stepOf_spec hUsp ht hR).1⟩
  let r   := M.rules.get rIdx
  -- Key facts from spec lemmas
  have hStepTrue : A (varStep t rId) = true := (stepOf_spec hUsp ht hR).2.1
  have hHeadSpec := headOf_spec hUhd (le_of_lt ht) hS
  have hHeadTrue : A (varHead t k) = true := hHeadSpec.2.1
  have hkLtS : k < S := hHeadSpec.1
  -- Rule validity
  have hRV := hRulesValid rIdx
  -- Extract the stepCNF from genTransition
  have hSatStep : Sat A (stepCNF S t k rId r) := by
    -- genTransition is a flatMap over t, k, (rId, rule) pairs
    rw [Sat, evalCNF', List.all_eq_true]
    intro clause hMem
    -- Need to show clause ∈ genTransition T S M
    have hMemTr : clause ∈ genTransition T S M := by
      unfold genTransition
      simp only [List.mem_flatMap, List.mem_range]
      refine ⟨t, ht, k, hkLtS, ?_⟩
      -- Need to show: ∃ a ∈ (List.range M.rules.length).zip M.rules, clause ∈ stepCNF S t k a.1 a.2
      refine ⟨(rId, r), ?_, hMem⟩
      -- (rId, r) ∈ (List.range M.rules.length).zip M.rules
      have : rId < M.rules.length := (stepOf_spec hUsp ht hR).1
      simp only [List.mem_iff_getElem]
      refine ⟨rId, ?_, ?_⟩
      · simp only [List.length_zip, List.length_range, min_self]; exact this
      · simp only [List.getElem_zip, List.getElem_range]
        rfl
    rw [Sat, evalCNF', List.all_eq_true] at hTr
    exact hTr clause hMemTr
  -- Apply sat_stepCNF_implies to get variable assignment facts
  have hImpl := sat_stepCNF_implies S t k rId r hSatStep ⟨hStepTrue, hHeadTrue⟩
  -- Extract all 5 components
  obtain ⟨hStateT, hTapeT, hStateT1, hTapeT1, hHeadT1⟩ := hImpl
  -- Convert to equalities using helper lemmas
  constructor
  · -- stateOf A T M.numStates t = r.q
    exact eq_stateOf_of_true hUst (le_of_lt ht) hNst hRV.1 hStateT
  constructor
  · -- tapeOf A T S M.numSymbols t k = r.s
    exact eq_tapeOf_of_true hUtp (le_of_lt ht) hkLtS hNsy hRV.2.1 hTapeT
  constructor
  · -- stateOf A T M.numStates (t+1) = r.q'
    exact eq_stateOf_of_true hUst (Nat.succ_le_of_lt ht) hNst hRV.2.2.1 hStateT1
  constructor
  · -- tapeOf A T S M.numSymbols (t+1) k = r.s'
    exact eq_tapeOf_of_true hUtp (Nat.succ_le_of_lt ht) hkLtS hNsy hRV.2.2.2 hTapeT1
  · -- headOf A T S (t+1) = movePos r.mv k
    have hMoveK : movePos r.mv k < S :=
      sat_stepCNF_implies_movePos_lt S t k rId r hS hkLtS hSatStep ⟨hStepTrue, hHeadTrue⟩
    exact eq_headOf_of_true hUhd (Nat.succ_le_of_lt ht) hS hMoveK hHeadT1

theorem sat_genInertia_implies_inertia
    {A : Assign} (T S numSymbols : ℕ)
    (hS : S > 0) (hNsy : numSymbols > 0)
    (hUhd : Sat A (uniqueHead T S))
    (hUtp : Sat A (uniqueTape T S numSymbols))
    (hIn  : Sat A (genInertia T S numSymbols)) :
    ∀ t < T, ∀ k < S, k ≠ headOf A T S t →
      tapeOf A T S numSymbols (t+1) k = tapeOf A T S numSymbols t k := by
  intro t ht k hkS hkNe
  -- 1. Show A (varHead t k) = false since k ≠ headOf
  have hHeadSpec := headOf_spec hUhd (le_of_lt ht) hS
  have hHeadFalse : A (varHead t k) = false := hHeadSpec.2.2 k hkS hkNe
  -- 2. Get the tape symbol at (t, k)
  have hTapeSpec := tapeOf_spec hUtp (le_of_lt ht) hkS hNsy
  let s := tapeOf A T S numSymbols t k
  have hsLt : s < numSymbols := hTapeSpec.1
  have hTapeTrue : A (varTape t k s) = true := hTapeSpec.2.1
  -- 3. Extract the inertia clause for (t, k, s) from genInertia
  have hSatInertia : Sat A (inertiaSymbol t k s) := by
    rw [Sat, evalCNF', List.all_eq_true]
    intro clause hMem
    have hMemIn : clause ∈ genInertia T S numSymbols := by
      unfold genInertia
      simp only [List.mem_flatMap, List.mem_range]
      exact ⟨t, ht, k, hkS, s, hsLt, hMem⟩
    rw [Sat, evalCNF', List.all_eq_true] at hIn
    exact hIn clause hMemIn
  -- 4. From inertia clause: ¬head(t,k) ∧ tape(t,k,s) → tape(t+1,k,s)
  -- inertiaSymbol gives us 2 clauses, we use the first one
  have hTape1True : A (varTape (t+1) k s) = true := by
    rw [inertiaSymbol, Sat, evalCNF', List.all_cons, List.all_cons, List.all_nil,
        Bool.and_true, Bool.and_eq_true] at hSatInertia
    obtain ⟨hC1, _⟩ := hSatInertia
    -- hC1: evalClause' A (impClause [neg (varHead t k), pos (varTape t k s)] (pos (varTape (t+1) k s))) = true
    simp only [impClause, evalClause', List.any_eq_true, List.mem_append, List.mem_map,
               notLit, neg, pos, evalLit', evalVar', List.mem_cons,
               List.mem_nil_iff, or_false] at hC1
    obtain ⟨lit, hMem, hEval⟩ := hC1
    rcases hMem with (⟨a, ha, rfl⟩ | rfl)
    · rcases ha with rfl | rfl <;> simp_all
    · simp only [] at hEval; exact hEval
  -- 5. Conclude tapeOf ... (t+1) k = s via eq_tapeOf_of_true
  exact eq_tapeOf_of_true hUtp (Nat.succ_le_of_lt ht) hkS hNsy hsLt hTape1True

/-! ### Tableau Semantics "Run" -/

/--
A structural representation of a tableau execution trace.
Everything is total (functions on ℕ), validity is a separate predicate.
-/
structure TableauRun where
  st   : ℕ → ℕ          -- State at time t (tagState)
  hd   : ℕ → ℕ          -- Head position at time t (tagHead)
  tape : ℕ → ℕ → ℕ      -- Tape symbol at (t, k) (tagTape)
  step : ℕ → ℕ          -- Transition step index at time t (tagStep)
  wit  : ℕ → Bool       -- Witness bits (tagWit)

/--
Predicates defining a "Valid" run according to the tableau constraints.
Corresponding to `genTableauAll`.
-/
structure ValidRun
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    (R : TableauRun) : Prop where
  -- 1. Bounds
  bounds_st   : ∀ t ≤ T, R.st t < M.numStates
  bounds_hd   : ∀ t ≤ T, R.hd t < S
  bounds_tape : ∀ t ≤ T, ∀ k < S, R.tape t k < M.numSymbols
  bounds_step : ∀ t < T, R.step t < M.rules.length

  -- 2. Init
  init_st   : R.st 0 = q0
  init_hd   : R.hd 0 = head0
  init_tape : ∀ k < S, R.tape 0 k =
    if k >= witOff ∧ k < witOff + witLen then
      if R.wit (k - witOff) then sym1 else sym0
    else tape0 k

  -- 3. Steps (uses movePos for consistency)
  step_valid : ∀ t, (ht : t < T) →
    let r := M.rules.get ⟨R.step t, bounds_step t ht⟩
    R.st t = r.q ∧ R.tape t (R.hd t) = r.s ∧
    R.st (t+1) = r.q' ∧
    R.tape (t+1) (R.hd t) = r.s' ∧
    R.hd (t+1) = movePos r.mv (R.hd t)

  inertia : ∀ t < T, ∀ k < S, k ≠ R.hd t → R.tape (t+1) k = R.tape t k

  -- 4. Accept
  accept : ∃ t ≤ T, R.st t = qAcc

/-- Canonical assignment induced by a TableauRun. -/
def assignOfRun
    (_T _S : ℕ) (_M : TableauMachine) (R : TableauRun) : Assign :=
  fun v =>
    let tag := v.unpair.1
    let rest := v.unpair.2
    let a := rest.unpair.1
    let rest2 := rest.unpair.2
    let b := rest2.unpair.1
    let c := rest2.unpair.2

    if tag = tagState then R.st a = b
    else if tag = tagHead then R.hd a = b
    else if tag = tagTape then R.tape a b = c
    else if tag = tagStep then R.step a = b
    else if tag = tagWit then if b = 0 then R.wit a else false
    else false

/-! ## A5. runOfAssign "propre" + théorèmes principaux Stage A -/

/-- Decode a run from a satisfying assignment using extracted values. -/
def runOfAssign'
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    (A : Assign)
    (_hA : Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1))
    : TableauRun :=
  { st   := fun t => stateOf A T M.numStates t
    hd   := fun t => headOf  A T S t
    tape := fun t k => tapeOf A T S M.numSymbols t k
    step := fun t => stepOf  A T M.numRules t
    wit  := fun i => A (varWit i) }

/-- Direction →: Sat A genTableauAll → ValidRun (runOfAssign' A). -/
theorem sat_genTableauAll_implies_validRun
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    -- Additional hypotheses for positivity and rule validity
    (hS   : S > 0) (hNst : M.numStates > 0) (hNsy : M.numSymbols > 0) (hR : M.rules.length > 0)
    (hq0  : q0 < M.numStates) (hHd0 : head0 < S) (hqAcc : qAcc < M.numStates)
    (hRulesValid : ∀ i : Fin M.rules.length,
        (M.rules.get i).q < M.numStates ∧
        (M.rules.get i).s < M.numSymbols ∧
        (M.rules.get i).q' < M.numStates ∧
        (M.rules.get i).s' < M.numSymbols)
    (hsym0 : sym0 < M.numSymbols) (hsym1 : sym1 < M.numSymbols)
    (htape0 : ∀ k < S, tape0 k < M.numSymbols)
    {A : Assign}
    (hA : Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)) :
    ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1
      (runOfAssign' T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 A hA) := by
  -- Extract all 9 components from genTableauAll
  rw [genTableauAll, sat_andCNFs_iff] at hA
  simp only [List.mem_cons, forall_eq_or_imp] at hA
  obtain ⟨hUst, hUhd, hUtp, hUsp, hTr, hIn, hInitC, hInitW, hAccept, _⟩ := hA
  -- Build ValidRun manually
  have hRules : M.numRules = M.rules.length := M.rules_len.symm
  have hR' : M.numRules > 0 := hRules ▸ hR
  -- Extract init facts from sat_genInitConst_iff
  have hInit := sat_genInitConst_iff S q0 head0 tape0 witOff witLen |>.mp hInitC
  exact {
    bounds_st   := fun t ht => (stateOf_spec hUst ht hNst).1
    bounds_hd   := fun t ht => (headOf_spec hUhd ht hS).1
    bounds_tape := fun t ht k hk => (tapeOf_spec hUtp ht hk hNsy).1
    bounds_step := fun t ht => hRules ▸ (stepOf_spec hUsp ht hR').1
    init_st     := by
      -- stateOf A T M.numStates 0 = q0
      have hT0 : (0 : ℕ) ≤ T := Nat.zero_le T
      exact eq_stateOf_of_true hUst hT0 hNst hq0 hInit.1
    init_hd     := by
      -- headOf A T S 0 = head0
      have hT0 : (0 : ℕ) ≤ T := Nat.zero_le T
      exact eq_headOf_of_true hUhd hT0 hS hHd0 hInit.2.1
    init_tape   := by
      intro k hkS
      simp only [runOfAssign']
      -- Split on whether k is in the witness window [witOff, witOff + witLen)
      by_cases hWin : k >= witOff ∧ k < witOff + witLen
      · -- Case: k in witness window
        simp only [hWin, ]
        -- Use sat_genInitWitness_iff
        have hWit := sat_genInitWitness_iff witLen witOff sym0 sym1 |>.mp hInitW
        have hIdx : k - witOff < witLen := by omega
        have hkEq : witOff + (k - witOff) = k := by omega
        specialize hWit (k - witOff) hIdx
        -- Split on varWit value
        by_cases hW : A (varWit (k - witOff)) = true
        · -- wit (k - witOff) = true → tapeOf = sym1
          simp only [hW, ite_true]
          have h1 : A (varTape 0 k sym1) = true := by rw [← hkEq]; exact hWit.1 hW
          have hT0 : (0 : ℕ) ≤ T := Nat.zero_le T
          exact eq_tapeOf_of_true hUtp hT0 hkS hNsy hsym1 h1
        · -- wit (k - witOff) = false → tapeOf = sym0
          have hWf : A (varWit (k - witOff)) = false := by simp_all
          simp only [hWf]
          have h0 : A (varTape 0 k sym0) = true := by rw [← hkEq]; exact hWit.2 hWf
          exact eq_tapeOf_of_true hUtp (Nat.zero_le T) hkS hNsy hsym0 h0
      · -- Case: k outside witness window
        have hOutside : k < witOff ∨ k >= witOff + witLen := by omega
        simp only [show ¬(k >= witOff ∧ k < witOff + witLen) by omega, ite_false]
        -- Use sat_genInitConst_iff
        have hConst : A (varTape 0 k (tape0 k)) = true := hInit.2.2 k hkS hOutside
        exact eq_tapeOf_of_true hUtp (Nat.zero_le T) hkS hNsy (htape0 k hkS) hConst
    step_valid  := by
      intro t ht
      -- Convert hUsp from M.numRules to M.rules.length using hRules
      have hUsp' : Sat A (uniqueStep T M.rules.length) := hRules.symm ▸ hUsp
      -- Apply sat_genTransition_implies_step_valid with correct argument order
      have hTrans := sat_genTransition_implies_step_valid T S M hUst hUhd hUtp hUsp'
                       hR hS hNst hNsy hRulesValid hTr t ht
      simp only [runOfAssign']
      -- Prove stepOf equality via hRules
      have hStepEq : stepOf A T M.numRules t = stepOf A T M.rules.length t := by
        rw [hRules]
      -- The rule access via List.get is the same because indices are equal
      have hIdxEq : (⟨stepOf A T M.numRules t, hRules ▸ (stepOf_spec hUsp' ht hR).1⟩ : Fin M.rules.length) =
                    ⟨stepOf A T M.rules.length t, (stepOf_spec hUsp' ht hR).1⟩ := by
        simp only [hStepEq]
      simp only [hStepEq] at hTrans ⊢
      exact hTrans
    inertia     := fun t ht k hk hkNe =>
      sat_genInertia_implies_inertia T S M.numSymbols hS hNsy hUhd hUtp hIn t ht k hk hkNe
    accept      := by
      -- Extract from hAccept : Sat A (genAccept T qAcc)
      -- genAccept T qAcc = [ (List.range (T+1)).map (fun t => pos (varState t qAcc)) ]
      rw [genAccept, Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true] at hAccept
      simp only [evalClause', List.any_eq_true, List.mem_map, List.mem_range] at hAccept
      -- hAccept : ∃ x, (∃ a < T+1, pos (varState a qAcc) = x) ∧ evalLit' A x = true
      obtain ⟨lit, ⟨t, htRange, hLitEq⟩, hEval⟩ := hAccept
      have htLe : t ≤ T := Nat.lt_succ_iff.mp htRange
      -- Simplify hEval using the fact that lit = pos (varState t qAcc)
      simp only [pos] at hLitEq
      subst hLitEq
      simp only [evalLit', evalVar'] at hEval
      -- hEval : A (varState t qAcc) = true
      refine ⟨t, htLe, ?_⟩
      simp only [runOfAssign']
      exact eq_stateOf_of_true hUst htLe hNst hqAcc hEval
  }

/-- Direction ←: ValidRun R → Sat (assignOfRun R) genTableauAll. -/
theorem validRun_implies_sat_genTableauAll
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    {R : TableauRun}
    (hR : ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) :
    Sat (assignOfRun T S M R)
      (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) := by
  -- Expand genTableauAll as ite_trueconjunction of 9 formulas
  rw [genTableauAll, sat_andCNFs_iff]
  simp only [List.mem_cons, forall_eq_or_imp, List.mem_nil_iff, false_implies, implies_true,
             and_true]
  -- Must prove each of the 9 components
  -- TODO: This requires lemmas for each component showing that assignOfRun
  -- satisfies uniqueState, uniqueHead, uniqueTape, uniqueStep, genTransition,
  -- genInertia, genInitConst, genInitWitness, genAccept respectively.
  -- Each would need its own helper lemma.
  sorry

/-! ### Main Theorems Stage A -/

/-- Satisfiability via assignment ↔ existence of valid run. -/
theorem tableau_sat_assign_iff_exists_run
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    (∃ A : Assign, Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)) ↔
    (∃ R : TableauRun, ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) := by
  -- TODO: Requires additional hypotheses (S > 0, numStates > 0, etc.)
  -- matching those in sat_genTableauAll_implies_validRun
  sorry

/-- CNF.Satisfiable version (for SATBundle compatibility). -/
theorem tableau_satisfiable_iff_exists_run
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    CNF.Satisfiable (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) ↔
    (∃ R : TableauRun, ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) :=
  (satisfiable_iff_exists_sat_assign _).trans (tableau_sat_assign_iff_exists_run T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)

/-- Polynomial bound on maxVar for genTableauAll (for SATBundle wBound compatibility). -/
theorem maxVar_genTableauAll_le_poly
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    maxVar (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) + 1 ≤
      tableauFullSizeBoundFun M (T + S) := by
  sorry


end RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas
