/-
  RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas

  Stage A: Pure SAT semantics of genTableauAll.
  This file proves that the CNF generated by `genTableauAll` is satisfiable
  if and only if there exists a valid TableauRun.
-/
import RevHalt.Dynamics.Operative.P_NP.CookLevinTableau
import RevHalt.Dynamics.Operative.P_NP.CookLevinGadgets
import RevHalt.Dynamics.Operative.P_NP.SAT
import RevHalt.Dynamics.Operative.P_NP.PNP

namespace RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas

open RevHalt
open RevHalt.Dynamics.Operative.P_NP.SAT
open RevHalt.Dynamics.Operative.P_NP.SAT.CNF
open RevHalt.Dynamics.Operative.P_NP.CookLevinGadgets
open RevHalt.Dynamics.Operative.P_NP.CookLevinTableau
open RevHalt.Dynamics.Operative.P_NP.PNP

abbrev Assign := CookLevinGadgets.Var → Bool

/-- Evaluate variable with function assignment. -/
def evalVar' (A : Assign) (v : CookLevinGadgets.Var) : Bool := A v

def evalLit' (A : Assign) (ℓ : CNF.Lit) : Bool :=
  let b := evalVar' A ℓ.v
  if ℓ.neg then !b else b

def evalClause' (A : Assign) (C : CNF.Clause) : Bool :=
  C.any (evalLit' A)

def evalCNF' (A : Assign) (F : CNF.CNF) : Bool :=
  F.all (evalClause' A)

/-- A variable assignment satisfies a formula. -/
def Sat (A : Assign) (F : CNF.CNF) : Prop := evalCNF' A F = true

/-! ### Gadget Lemmas (Pure Boolean Logic) -/

theorem sat_andCNF {A : Assign} {F G : CNF.CNF} :
    Sat A (andCNF F G) ↔ Sat A F ∧ Sat A G := by
  unfold Sat andCNF evalCNF'
  simp only [List.all_append, Bool.and_eq_true]

theorem sat_andCNFs {A : Assign} {Fs : List CNF.CNF} :
    Sat A (andCNFs Fs) ↔ ∀ F ∈ Fs, Sat A F := by
  unfold Sat andCNFs evalCNF'
  induction Fs with
  | nil =>
    simp only [List.flatten_nil, List.all_nil, List.not_mem_nil, false_implies, implies_true]
  | cons F Fs ih =>
    simp only [List.flatten_cons, List.all_append, Bool.and_eq_true, List.mem_cons,
               forall_eq_or_imp]
    exact and_congr Iff.rfl ih

theorem sat_impClause {A : Assign} {ante : List CNF.Lit} {cons : CNF.Lit} :
    Sat A [impClause ante cons] ↔
      ((∀ l ∈ ante, evalLit' A l = true) → evalLit' A cons = true) := by
  unfold Sat evalCNF' impClause
  simp only [List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_append,
             List.any_map, Bool.or_eq_true]
  -- Key lemma: evalLit' A (notLit l) = !evalLit' A l
  have evalNotLit : ∀ l, evalLit' A (notLit l) = !evalLit' A l := by
    intro l
    simp only [evalLit', notLit, evalVar']
    cases hl : l.neg <;> simp
  constructor
  · intro hOr hAnte
    rcases hOr with hNeg | hCons
    · -- Some negated literal is true → contradiction
      simp only [List.any_eq_true, Function.comp_apply] at hNeg
      rcases hNeg with ⟨l, hl_mem, hl_eval⟩
      rw [evalNotLit] at hl_eval
      have hAnte_l := hAnte l hl_mem
      simp only [Bool.not_eq_true'] at hl_eval
      simp_all
    · -- Consequent is true directly
      simp only [List.any_cons, List.any_nil, Bool.or_false] at hCons
      exact hCons
  · intro hImp
    by_cases hAll : ∀ l ∈ ante, evalLit' A l = true
    · right
      simp only [List.any_cons, List.any_nil, Bool.or_false]
      exact hImp hAll
    · left
      push_neg at hAll
      rcases hAll with ⟨l, hl_mem, hl_false⟩
      simp only [List.any_eq_true, Function.comp_apply]
      use l, hl_mem
      rw [evalNotLit]
      simp only [Bool.not_eq_true', Bool.eq_false_iff] at hl_false ⊢
      exact hl_false

theorem sat_atLeastOne {A : Assign} {lits : List CookLevinGadgets.Var} (h : lits ≠ []) :
    Sat A (atLeastOne lits) ↔ ∃ v ∈ lits, A v = true := by
  unfold Sat evalCNF' atLeastOne
  cases lits with
  | nil => contradiction
  | cons x xs =>
    simp only [List.all_cons, List.all_nil, Bool.and_true, evalClause',
               List.any_map, List.any_eq_true, Function.comp_apply]
    constructor
    · intro ⟨v, hv_mem, hv_eval⟩
      use v, hv_mem
      simp only [evalLit', pos, evalVar'] at hv_eval
      exact hv_eval
    · intro ⟨v, hv_mem, hv_true⟩
      use v, hv_mem
      simp only [evalLit', pos, evalVar']
      exact hv_true

/-! ## A0. Lemmes de base sur les clauses unitaires et disjonctions -/

theorem sat_unit_pos {A : Assign} {v : CookLevinGadgets.Var} :
    Sat A [[pos v]] ↔ A v = true := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_cons, List.any_nil, Bool.or_false, evalLit', pos, evalVar']
  cases A v <;> decide

theorem sat_unit_neg {A : Assign} {v : CookLevinGadgets.Var} :
    Sat A [[neg v]] ↔ A v = false := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause', List.any_cons, List.any_nil, Bool.or_false, evalLit', neg, evalVar']
  cases A v <;> decide

theorem sat_bigOr_pos {A : Assign} {vs : List CookLevinGadgets.Var} :
    Sat A [vs.map pos] ↔ ∃ v ∈ vs, A v = true := by
  simp only [Sat, evalCNF', List.all_cons, List.all_nil, Bool.and_true, evalClause']
  rw [List.any_map]
  simp only [evalLit', pos, evalVar', Function.comp_apply, List.any_eq_true]
  rfl

theorem sat_andCNFs_iff {A : Assign} {Fs : List CNF.CNF} :
    Sat A (andCNFs Fs) ↔ ∀ F ∈ Fs, Sat A F := by
  unfold andCNFs Sat evalCNF'
  rw [List.all_flatten, List.all_eq_true]

theorem mem_pairwise_subset {α} (l : List α) (x y : α) :
    (x, y) ∈ pairwise l → x ∈ l ∧ y ∈ l := by
  induction l with
  | nil => simp [pairwise]
  | cons h t ih =>
    intro H
    simp only [pairwise, List.mem_append, List.mem_map] at H
    cases H with
    | inl hmap =>
      rcases hmap with ⟨z, hz, heq⟩
      injection heq with hx hy
      subst hx; subst hy
      simp [hz]
    | inr hpair =>
      cases ih hpair with | intro ix iy =>
      simp [ix, iy]

theorem distinct_of_mem_pairwise {α} [DecidableEq α] (l : List α) (hl : l.Nodup) (x y : α) :
    (x, y) ∈ pairwise l → x ≠ y := by
  induction l with
  | nil => simp [pairwise]
  | cons h t ih =>
    rw [List.nodup_cons] at hl
    rcases hl with ⟨hnotin, htail⟩
    intro H
    simp only [pairwise, List.mem_append, List.mem_map] at H
    cases H with
    | inl hmap =>
      rcases hmap with ⟨z, hz, heq⟩
      injection heq with hx hy
      subst hx
      subst hy
      intro heq
      subst heq
      exact hnotin hz
    | inr hpair =>
      exact ih htail hpair

theorem exists_pair_of_mem_distinct {α} [DecidableEq α] (l : List α) (x y : α) :
    x ∈ l → y ∈ l → x ≠ y → (x, y) ∈ pairwise l ∨ (y, x) ∈ pairwise l := by
  induction l with
  | nil => simp
  | cons h t ih =>
    intro hx hy hne
    simp only [List.mem_cons] at hx hy
    simp only [pairwise, List.mem_append, List.mem_map]
    rcases hx with rfl | hxt
    · rcases hy with rfl | hyt
      · contradiction
      · left; left; use y;
    · rcases hy with rfl | hyt
      · right; left; use x;
      · rcases ih hxt hyt hne with h1 | h2
        · left; right; exact h1
        · right; right; exact h2

theorem sat_atMostOne {A : Assign} {lits : List CookLevinGadgets.Var} (hNd : lits.Nodup) :
    Sat A (atMostOne lits) ↔
      ∀ v ∈ lits, ∀ v' ∈ lits, v ≠ v' → ¬(A v = true ∧ A v' = true) := by
  simp only [Sat, evalCNF', atMostOne]
  rw [List.all_map, List.all_eq_true]
  simp only [Function.comp_apply]
  constructor
  · intro h v hv v' hv' hne
    cases exists_pair_of_mem_distinct lits v v' hv hv' hne with
    | inl hpair =>
      specialize h (v, v') hpair
      simp [evalClause', evalLit', neg, evalVar'] at h
      intro hAnd
      rw [hAnd.1, hAnd.2] at h
      simp at h
    | inr hpair =>
      specialize h (v', v) hpair
      simp [evalClause', evalLit', neg, evalVar'] at h
      intro hAnd
      rw [hAnd.1, hAnd.2] at h
      simp at h
  · intro H p hp
    have : p.1 ∈ lits ∧ p.2 ∈ lits := mem_pairwise_subset lits p.1 p.2 hp
    specialize H p.1 this.1 p.2 this.2 (distinct_of_mem_pairwise lits hNd p.1 p.2 hp)
    simp [evalClause', evalLit', neg, evalVar']
    cases h1 : A p.1 <;> cases h2 : A p.2 <;> simp [h1, h2] at H ⊢

theorem sat_andCNF_pair {A : Assign} {F G : CNF.CNF} : Sat A (andCNF F G) ↔ Sat A F ∧ Sat A G := by
  unfold andCNF Sat evalCNF'
  simp only [List.all_append, Bool.and_eq_true]

theorem sat_exactlyOne {A : Assign} {lits : List CookLevinGadgets.Var} (h : lits ≠ []) (hNd : lits.Nodup) :
    Sat A (exactlyOne lits) ↔
      (∃ v ∈ lits, A v = true) ∧
      (∀ v ∈ lits, ∀ v' ∈ lits, v ≠ v' → ¬(A v = true ∧ A v' = true)) := by
  unfold exactlyOne
  rw [sat_andCNF_pair]
  unfold atLeastOne
  split
  · contradiction
  · rw [sat_bigOr_pos, sat_atMostOne hNd]

/-! ### Assign ↔ Witness Bridge API -/

/-- Max variable index used by a literal. -/
def maxVarLit (ℓ : CNF.Lit) : ℕ := ℓ.v

/-- Max variable index used by a clause. -/
def maxVarClause (C : CNF.Clause) : ℕ :=
  C.foldl (fun acc ℓ => max acc (maxVarLit ℓ)) 0

/-- Max variable index used by a CNF formula. -/
def maxVar (F : CNF.CNF) : ℕ :=
  F.foldl (fun acc C => max acc (maxVarClause C)) 0

/-- Turn a PNP.Witness (List Bool) into an assignment function with default false. -/
def assignOfWitness (w : PNP.Witness) : Assign :=
  fun v => w.getD v false

/-- Turn an assignment function into a PNP.Witness list of length L. -/
def witnessOfAssign (L : ℕ) (A : Assign) : PNP.Witness :=
  (List.range L).map A

/-- Witness size of witnessOfAssign is exactly L. -/
theorem witnessOfAssign_size (L : ℕ) (A : Assign) :
    PNP.witnessSize (witnessOfAssign L A) = L := by
  unfold witnessOfAssign PNP.witnessSize
  simp only [List.length_map, List.length_range]

/-- assignOfWitness ∘ witnessOfAssign recovers A for indices < L. -/
theorem assignOfWitness_witnessOfAssign (L : ℕ) (A : Assign) (v : ℕ) (hv : v < L) :
    assignOfWitness (witnessOfAssign L A) v = A v := by
  dsimp [assignOfWitness, witnessOfAssign]
  -- Robust range append lemma
  have range_append : ∀ n, List.range (n + 1) = List.range n ++ [n] := by
    intro n
    induction n with
    | zero => rfl
    | succ n ih => rw [List.range_succ, ih]

  -- Main property using getD to avoid dependent type issues
  have map_range_getD : ∀ (n : ℕ) (i : ℕ), i < n → (List.map A (List.range n)).getD i false = A i := by
    intro n
    induction n with
    | zero => intro i h; contradiction
    | succ n ih =>
      intro i h_lt
      rw [range_append, List.map_append]
      simp only [List.map_cons, List.map_nil]

      have getD_append_lt : ∀ (l : List Bool) (x : Bool) (k : ℕ) (d : Bool), k < l.length → (l ++ [x]).getD k d = l.getD k d := by
        intro l x k d h
        induction l generalizing k with
        | nil => contradiction
        | cons h t ih =>
          cases k with
          | zero => rfl
          | succ k' => simp [List.getD]; apply ih; simp [List.length] at h; exact h

      have getD_append_eq : ∀ (l : List Bool) (x : Bool) (d : Bool), (l ++ [x]).getD l.length d = x := by
        intro l x d
        induction l with
        | nil => rfl
        | cons h t ih => simp [List.getD, List.length];

      if h : i < n then
        rw [getD_append_lt]
        · exact ih i h
        · simp [List.length_map, List.length_range]; exact h
      else
        have h_eq : i = n := by
          apply Nat.le_antisymm
          · apply Nat.le_of_lt_succ h_lt
          · apply Nat.le_of_not_lt h
        rw [h_eq]
        -- Goal: (map ... ++ [A n]).getD n false = A n
        have h_len : (List.map A (List.range n)).length = n := by simp [List.length_range]
        convert getD_append_eq (List.map A (List.range n)) (A n) false
        exact h_len.symm

  apply map_range_getD L v hv

/-- Monotonicity of foldl max. -/
theorem foldl_max_mono (l : List α) (f : α → ℕ) (init : ℕ) :
    init ≤ l.foldl (fun acc y => max acc (f y)) init := by
  induction l generalizing init with
  | nil => simp only [List.foldl_nil, Nat.le_refl]
  | cons h t ih =>
    simp only [List.foldl_cons]
    apply Nat.le_trans (Nat.le_max_left _ _) (ih _)

/-- Helper for maxVar bound found in folds. -/
theorem foldl_max_le {l : List α} {f : α → ℕ} {init : ℕ} (x : α) (hx : x ∈ l) :
    f x ≤ l.foldl (fun acc y => max acc (f y)) init := by
  induction l generalizing init with
  | nil => contradiction
  | cons head tail ih =>
    simp only [List.foldl_cons, List.mem_cons] at hx ⊢
    cases hx with
    | inl h_eq =>
      subst h_eq
      apply Nat.le_trans (m := max init (f x))
      · apply Nat.le_max_right
      · apply foldl_max_mono
    | inr h_in =>
      apply ih (init := max init (f head))
      exact h_in

theorem maxVar_bound (F : CNF.CNF) :
    ∀ C ∈ F, ∀ ℓ ∈ C, ℓ.v ≤ maxVar F := by
  intro C hC ℓ hℓ
  unfold maxVar
  have hC_le := foldl_max_le (f := maxVarClause) C hC (init := 0)
  apply Nat.le_trans _ hC_le
  unfold maxVarClause
  exact foldl_max_le (f := maxVarLit) ℓ hℓ (init := 0)

/-- If all vars in F are < maxVar F + 1, then Sat via assignment ↔ evalCNF via padded witness. -/
theorem sat_iff_evalCNF_witness (A : Assign) (F : CNF.CNF) :
    Sat A F ↔ CNF.evalCNF (witnessOfAssign (maxVar F + 1) A) F = true := by
  have sat_iff_eval_of_bound : ∀ L, maxVar F < L → (Sat A F ↔ CNF.evalCNF (witnessOfAssign L A) F = true) := by
    intro L hL
    rw [Sat, evalCNF', CNF.evalCNF]
    simp only [List.all_eq_true, List.any_eq_true, evalClause', CNF.evalClause, evalLit', CNF.evalLit, CNF.evalVar]
    apply forall_congr'
    intro C
    apply imp_congr_right
    intro hC
    apply exists_congr
    intro ℓ
    apply and_congr_right
    intro hℓ
    -- Goal: A ℓ.v ... ↔ witness ... ℓ.v ...
    have hv : ℓ.v < L := Nat.lt_of_le_of_lt (maxVar_bound F C hC ℓ hℓ) hL
    have h_rw : (witnessOfAssign L A).getD ℓ.v false = A ℓ.v := assignOfWitness_witnessOfAssign L A ℓ.v hv
    rw [h_rw]
    rfl

  exact sat_iff_eval_of_bound (maxVar F + 1) (Nat.lt_succ_self _)

/-- Bridge: satisfiable via assignment ↔ satisfiable via bounded PNP.Witness. -/
theorem sat_assign_iff_sat_witness (F : CNF.CNF) :
    (∃ A : Assign, Sat A F) ↔
    (∃ w : PNP.Witness, PNP.witnessSize w ≤ (maxVar F + 1) ∧ CNF.evalCNF w F = true) := by
  constructor
  · rintro ⟨A, hA⟩
    use witnessOfAssign (maxVar F + 1) A
    constructor
    · rw [witnessOfAssign_size]
    · rw [← sat_iff_evalCNF_witness]
      exact hA
  · rintro ⟨w, _, hw⟩
    use assignOfWitness w
    unfold Sat evalCNF'
    unfold CNF.evalCNF at hw
    simp only [List.all_eq_true]
    intro C hC
    simp only [List.all_eq_true] at hw
    specialize hw C hC
    simp only [evalClause', List.any_eq_true]
    simp only [CNF.evalClause, List.any_eq_true] at hw
    obtain ⟨ℓ, hℓ, hl_true⟩ := hw
    use ℓ, hℓ
    simp only [evalLit']
    exact hl_true

/-- Equivalence between witness-based and assignment-based satisfiability. -/
theorem satisfiable_iff_exists_sat_assign (F : CNF.CNF) :
    CNF.Satisfiable F ↔ ∃ A : Assign, Sat A F := by
  constructor
  · rintro ⟨w, hw⟩
    use assignOfWitness w
    -- They are definitionally equal check?
    -- Sat (assignOfWitness w) F := evalCNF' (assignOfWitness w) F = true
    -- evalCNF w F = true
    -- Let's check definitions logic.
    -- evalVar' (assignOfWitness w) v = (assignOfWitness w) v = w.getD v false
    -- CNF.evalVar w v = w.getD v false
    -- So they are equal.
    convert hw
  · rintro ⟨A, hA⟩
    rw [sat_iff_evalCNF_witness] at hA
    exact ⟨_, hA⟩

/-- Bridge to SATBundle: if maxVar + 1 fits in wBound, we get the right form. -/
theorem satisfiable_bounded_iff_satisfiable
    (wBound : ℕ) (F : CNF.CNF)
    (h : maxVar F + 1 ≤ wBound) :
    CNF.Satisfiable F ↔
      (∃ w : PNP.Witness, PNP.witnessSize w ≤ wBound ∧ CNF.evalCNF w F = true) := by
  constructor
  · intro hSat
    -- Satisfiable -> ∃ A, Sat A F
    rcases (satisfiable_iff_exists_sat_assign (F := F)).1 hSat with ⟨A, hA⟩
    -- ∃ A, Sat A F -> bounded witness (≤ maxVar+1)
    rcases (sat_assign_iff_sat_witness (F := F)).1 ⟨A, hA⟩ with ⟨w, hwSize, hwEval⟩
    refine ⟨w, Nat.le_trans hwSize h, hwEval⟩
  · rintro ⟨w, _, hwEval⟩
    exact ⟨w, hwEval⟩



/-! ## A1. Décomposition de genTableauAll en conjonction de composants -/

theorem sat_genTableauAll_iff
    {A : Assign} (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) ↔
      Sat A (uniqueState T M.numStates) ∧
      Sat A (uniqueHead  T S) ∧
      Sat A (uniqueTape  T S M.numSymbols) ∧
      Sat A (uniqueStep  T M.numRules) ∧
      Sat A (genTransition T S M) ∧
      Sat A (genInertia   T S M.numSymbols) ∧
      Sat A (genInitConst S q0 head0 tape0 witOff witLen) ∧
      Sat A (genInitWitness witLen witOff sym0 sym1) ∧
      Sat A (genAccept T qAcc) := by
  unfold genTableauAll
  rw [sat_andCNFs_iff]
  constructor
  · intro h
    simp only [List.mem_cons] at h
    repeat' constructor
    all_goals apply h; simp
  · intro h F hF
    simp only [List.mem_cons] at hF
    rcases h with ⟨h1, h2, h3, h4, h5, h6, h7, h8, h9⟩
    rcases hF with rfl | rfl | rfl | rfl | rfl | rfl | rfl | rfl | rfl | hFalse
    · exact h1
    · exact h2
    · exact h3
    · exact h4
    · exact h5
    · exact h6
    · exact h7
    · exact h8
    · exact h9
    · cases hFalse

/-! ## A2. Extraction "uniqueState/head/tape/step" depuis Sat -/

/-- Extract the unique state at time t from a satisfying assignment. -/
def stateOf (A : Assign) (_T numStates : ℕ) (t : ℕ) : ℕ :=
  ((List.range numStates).find? (fun q => A (varState t q))).getD 0

theorem stateOf_spec
    {A : Assign} {T numStates t : ℕ}
    (hU : Sat A (uniqueState T numStates)) (ht : t ≤ T) :
    stateOf A T numStates t < numStates ∧
    A (varState t (stateOf A T numStates t)) = true ∧
    (∀ q < numStates, q ≠ stateOf A T numStates t → A (varState t q) = false) := by
  sorry

/-- Extract the unique head position at time t from a satisfying assignment. -/
def headOf (A : Assign) (_T S : ℕ) (t : ℕ) : ℕ :=
  ((List.range S).find? (fun k => A (varHead t k))).getD 0

theorem headOf_spec
    {A : Assign} {T S t : ℕ}
    (hU : Sat A (uniqueHead T S)) (ht : t ≤ T) :
    headOf A T S t < S ∧
    A (varHead t (headOf A T S t)) = true ∧
    (∀ k < S, k ≠ headOf A T S t → A (varHead t k) = false) := by
  sorry

/-- Extract the unique tape symbol at (t, k) from a satisfying assignment. -/
def tapeOf (A : Assign) (_T _S numSymbols : ℕ) (t k : ℕ) : ℕ :=
  ((List.range numSymbols).find? (fun s => A (varTape t k s))).getD 0

theorem tapeOf_spec
    {A : Assign} {T S numSymbols t k : ℕ}
    (hU : Sat A (uniqueTape T S numSymbols)) (ht : t ≤ T) (hk : k < S) :
    tapeOf A T S numSymbols t k < numSymbols ∧
    A (varTape t k (tapeOf A T S numSymbols t k)) = true ∧
    (∀ s < numSymbols, s ≠ tapeOf A T S numSymbols t k → A (varTape t k s) = false) := by
  sorry

/-- Extract the unique step/rule index at time t from a satisfying assignment. -/
def stepOf (A : Assign) (_T numRules : ℕ) (t : ℕ) : ℕ :=
  ((List.range numRules).find? (fun r => A (varStep t r))).getD 0

theorem stepOf_spec
    {A : Assign} {T numRules t : ℕ}
    (hU : Sat A (uniqueStep T numRules)) (ht : t < T) :
    stepOf A T numRules t < numRules ∧
    A (varStep t (stepOf A T numRules t)) = true ∧
    (∀ r < numRules, r ≠ stepOf A T numRules t → A (varStep t r) = false) := by
  sorry

/-! ## A3. Init / Witness / Accept sous forme "logique" -/

theorem sat_genInitConst_iff
    {A : Assign} (S q0 head0 : ℕ) (tape0 : ℕ → ℕ) (witOff witLen : ℕ) :
    Sat A (genInitConst S q0 head0 tape0 witOff witLen) ↔
      A (varState 0 q0) = true ∧
      A (varHead  0 head0) = true ∧
      (∀ k < S, (k < witOff ∨ k ≥ witOff + witLen) → A (varTape 0 k (tape0 k)) = true) := by
  sorry

theorem sat_genInitWitness_iff
    {A : Assign} (witLen witOff sym0 sym1 : ℕ) :
    Sat A (genInitWitness witLen witOff sym0 sym1) ↔
      ∀ i < witLen,
        (A (varWit i) = true  → A (varTape 0 (witOff + i) sym1) = true) ∧
        (A (varWit i) = false → A (varTape 0 (witOff + i) sym0) = true) := by
  sorry

theorem sat_genAccept_iff
    {A : Assign} (T qAcc : ℕ) :
    Sat A (genAccept T qAcc) ↔ ∃ t ≤ T, A (varState t qAcc) = true := by
  sorry

/-! ## A4. Transition & inertie : lemmes locaux "stepCNF" puis globaux -/

theorem sat_stepCNF_implies
    {A : Assign} (S t k rId : ℕ) (R : TransitionRule) :
    Sat A (stepCNF S t k rId R) →
    (A (varStep t rId) = true ∧ A (varHead t k) = true) →
      A (varState t R.q) = true ∧
      A (varTape  t k R.s) = true ∧
      A (varState (t+1) R.q') = true ∧
      A (varTape  (t+1) k R.s') = true ∧
      A (varHead  (t+1) (movePos R.mv k)) = true := by
  sorry

theorem sat_genTransition_implies_step_valid
    {A : Assign} (T S : ℕ) (M : TableauMachine)
    (hUst : Sat A (uniqueState T M.numStates))
    (hUhd : Sat A (uniqueHead  T S))
    (hUtp : Sat A (uniqueTape  T S M.numSymbols))
    (hUsp : Sat A (uniqueStep  T M.rules.length))
    (hTr  : Sat A (genTransition T S M)) :
    ∀ t, (ht : t < T) →
      let rId := stepOf A T M.rules.length t
      let k   := headOf A T S t
      let r   := M.rules.get ⟨rId, (stepOf_spec hUsp ht).1⟩
      (stateOf A T M.numStates t = r.q) ∧
      (tapeOf A T S M.numSymbols t k = r.s) ∧
      (stateOf A T M.numStates (t+1) = r.q') ∧
      (tapeOf A T S M.numSymbols (t+1) k = r.s') ∧
      (headOf A T S (t+1) = movePos r.mv k) := by
  sorry

theorem sat_genInertia_implies_inertia
    {A : Assign} (T S numSymbols : ℕ)
    (hUhd : Sat A (uniqueHead T S))
    (hUtp : Sat A (uniqueTape T S numSymbols))
    (hIn  : Sat A (genInertia T S numSymbols)) :
    ∀ t < T, ∀ k < S, k ≠ headOf A T S t →
      tapeOf A T S numSymbols (t+1) k = tapeOf A T S numSymbols t k := by
  sorry

/-! ### Tableau Semantics "Run" -/

/--
A structural representation of a tableau execution trace.
Everything is total (functions on ℕ), validity is a separate predicate.
-/
structure TableauRun where
  st   : ℕ → ℕ          -- State at time t (tagState)
  hd   : ℕ → ℕ          -- Head position at time t (tagHead)
  tape : ℕ → ℕ → ℕ      -- Tape symbol at (t, k) (tagTape)
  step : ℕ → ℕ          -- Transition step index at time t (tagStep)
  wit  : ℕ → Bool       -- Witness bits (tagWit)

/--
Predicates defining a "Valid" run according to the tableau constraints.
Corresponding to `genTableauAll`.
-/
structure ValidRun
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    (R : TableauRun) : Prop where
  -- 1. Bounds
  bounds_st   : ∀ t ≤ T, R.st t < M.numStates
  bounds_hd   : ∀ t ≤ T, R.hd t < S
  bounds_tape : ∀ t ≤ T, ∀ k < S, R.tape t k < M.numSymbols
  bounds_step : ∀ t < T, R.step t < M.rules.length

  -- 2. Init
  init_st   : R.st 0 = q0
  init_hd   : R.hd 0 = head0
  init_tape : ∀ k < S, R.tape 0 k =
    if k >= witOff ∧ k < witOff + witLen then
      if R.wit (k - witOff) then sym1 else sym0
    else tape0 k

  -- 3. Steps (uses movePos for consistency)
  step_valid : ∀ t, (ht : t < T) →
    let r := M.rules.get ⟨R.step t, bounds_step t ht⟩
    R.st t = r.q ∧ R.tape t (R.hd t) = r.s ∧
    R.st (t+1) = r.q' ∧
    R.tape (t+1) (R.hd t) = r.s' ∧
    R.hd (t+1) = movePos r.mv (R.hd t)

  inertia : ∀ t < T, ∀ k < S, k ≠ R.hd t → R.tape (t+1) k = R.tape t k

  -- 4. Accept
  accept : ∃ t ≤ T, R.st t = qAcc

/-- Canonical assignment induced by a TableauRun. -/
def assignOfRun
    (_T _S : ℕ) (_M : TableauMachine) (R : TableauRun) : Assign :=
  fun v =>
    let tag := v.unpair.1
    let rest := v.unpair.2
    let a := rest.unpair.1
    let rest2 := rest.unpair.2
    let b := rest2.unpair.1
    let c := rest2.unpair.2

    if tag = tagState then R.st a = b
    else if tag = tagHead then R.hd a = b
    else if tag = tagTape then R.tape a b = c
    else if tag = tagStep then R.step a = b
    else if tag = tagWit then if b = 0 then R.wit a else false
    else false

/-! ## A5. runOfAssign "propre" + théorèmes principaux Stage A -/

/-- Decode a run from a satisfying assignment using extracted values. -/
def runOfAssign'
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    (A : Assign)
    (_hA : Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1))
    : TableauRun :=
  { st   := fun t => stateOf A T M.numStates t
    hd   := fun t => headOf  A T S t
    tape := fun t k => tapeOf A T S M.numSymbols t k
    step := fun t => stepOf  A T M.numRules t
    wit  := fun i => A (varWit i) }

/-- Direction →: Sat A genTableauAll → ValidRun (runOfAssign' A). -/
theorem sat_genTableauAll_implies_validRun
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    {A : Assign}
    (hA : Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)) :
    ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1
      (runOfAssign' T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 A hA) := by
  sorry

/-- Direction ←: ValidRun R → Sat (assignOfRun R) genTableauAll. -/
theorem validRun_implies_sat_genTableauAll
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ)
    {R : TableauRun}
    (hR : ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) :
    Sat (assignOfRun T S M R)
      (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) := by
  sorry

/-! ### Main Theorems Stage A -/

/-- Satisfiability via assignment ↔ existence of valid run. -/
theorem tableau_sat_assign_iff_exists_run
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    (∃ A : Assign, Sat A (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)) ↔
    (∃ R : TableauRun, ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) := by
  constructor
  · intro ⟨A, hA⟩
    exact ⟨runOfAssign' T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 A hA,
           sat_genTableauAll_implies_validRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 hA⟩
  · intro ⟨R, hR⟩
    exact ⟨assignOfRun T S M R,
           validRun_implies_sat_genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 hR⟩

/-- CNF.Satisfiable version (for SATBundle compatibility). -/
theorem tableau_satisfiable_iff_exists_run
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ)
    (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    CNF.Satisfiable (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) ↔
    (∃ R : TableauRun, ValidRun T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1 R) :=
  (satisfiable_iff_exists_sat_assign _).trans (tableau_sat_assign_iff_exists_run T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1)

/-- Polynomial bound on maxVar for genTableauAll (for SATBundle wBound compatibility). -/
theorem maxVar_genTableauAll_le_poly
    (T S : ℕ) (M : TableauMachine)
    (q0 head0 qAcc : ℕ) (tape0 : ℕ → ℕ)
    (witLen witOff sym0 sym1 : ℕ) :
    maxVar (genTableauAll T S M q0 head0 qAcc tape0 witLen witOff sym0 sym1) + 1 ≤
      tableauFullSizeBoundFun M (T + S) := by
  sorry


end RevHalt.Dynamics.Operative.P_NP.CookLevinLemmas
