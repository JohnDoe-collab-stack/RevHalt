import RevHalt.Theory.RelativeR1
import Mathlib.Data.Fintype.Card
import Mathlib.Data.Fintype.Pigeonhole

/-!
# Orbit Grammar: Eventually Periodic Dynamics + Pigeonhole

This file proves **LPO_R1 for finite orbit grammars** via pigeonhole:
- `¬AdmitsConst` holds when σ has no fixed points
- `LPO_R1` holds because orbits repeat within |α| steps

## The Key Insight (Pigeonhole)

For finite α with |α| = n:
- An orbit visits n+1 positions in n slots → must repeat by pigeonhole
- Once it repeats, it's periodic
- Therefore all values appear within the first n steps
- So LPO_R1 = search up to n

-/

namespace RevHalt.OrbitGrammar

variable {α : Type*}

-- ═══════════════════════════════════════════════════════════════════════════════
-- 1) Orbit Grammar Definition
-- ═══════════════════════════════════════════════════════════════════════════════

/-- Orbit sequence generated by dynamics σ. -/
def orbit (σ : α → α) (x₀ : α) : ℕ → α :=
  fun n => σ^[n] x₀

/-- Orbit grammar: sequences that are orbits of σ. -/
def OrbitAdm (σ : α → α) : (ℕ → α) → Prop :=
  fun s => ∃ x₀, s = orbit σ x₀

-- ═══════════════════════════════════════════════════════════════════════════════
-- 2) No Fixed Points ⟹ ¬AdmitsConst
-- ═══════════════════════════════════════════════════════════════════════════════

/-- σ has no fixed points. -/
def NoFixedPoint (σ : α → α) : Prop :=
  ∀ x, σ x ≠ x

/-- If σ has no fixed points, constant sequences are not orbits. -/
theorem orbit_not_const (σ : α → α) (hNFP : NoFixedPoint σ) (c : α) :
    ¬ OrbitAdm σ (fun _ => c) := by
  intro ⟨x₀, hEq⟩
  have h0 : x₀ = c := by
    have : orbit σ x₀ 0 = (fun _ => c) 0 := congrFun hEq.symm 0
    simp only [orbit, Function.iterate_zero] at this
    exact this
  have h1 : σ x₀ = c := by
    have : orbit σ x₀ 1 = (fun _ => c) 1 := congrFun hEq.symm 1
    simp only [orbit, Function.iterate_one] at this
    exact this
  rw [h0] at h1
  exact hNFP c h1

-- ═══════════════════════════════════════════════════════════════════════════════
-- 3) Bounded Search
-- ═══════════════════════════════════════════════════════════════════════════════

/-- Decidable search up to bound. -/
def existsUpTo (P : ℕ → Prop) [∀ n, Decidable (P n)] (bound : ℕ) :
    Decidable (∃ n, n ≤ bound ∧ P n) := by
  induction bound with
  | zero =>
    by_cases h : P 0
    · exact isTrue ⟨0, Nat.le_refl 0, h⟩
    · exact isFalse (fun ⟨n, hn, hPn⟩ => by simp at hn; subst hn; exact h hPn)
  | succ k ih =>
    cases ih with
    | isTrue hEx =>
      exact isTrue (hEx.elim fun n ⟨hn, hPn⟩ => ⟨n, Nat.le_succ_of_le hn, hPn⟩)
    | isFalse hNot =>
      by_cases hk : P (k + 1)
      · exact isTrue ⟨k + 1, Nat.le_refl _, hk⟩
      · exact isFalse (fun ⟨n, hn, hPn⟩ => by
          cases Nat.lt_succ_iff_lt_or_eq.mp (Nat.lt_succ_of_le hn) with
          | inl hlt => exact hNot ⟨n, Nat.lt_succ_iff.mp hlt, hPn⟩
          | inr heq => rw [heq] at hPn; exact hk hPn)

-- ═══════════════════════════════════════════════════════════════════════════════
-- 4) Pigeonhole: Finite State ⟹ Orbit Repeats
-- ═══════════════════════════════════════════════════════════════════════════════

section PigeonholeFintype

variable [Fintype α]

/-- THE PIGEONHOLE LEMMA: For finite α, orbits repeat within card α steps. -/
theorem orbit_repeats (σ : α → α) (x₀ : α) :
    ∃ i j, i < j ∧ j ≤ Fintype.card α ∧ orbit σ x₀ i = orbit σ x₀ j := by
  let f : Fin (Fintype.card α + 1) → α := fun n => orbit σ x₀ n
  have hCard : Fintype.card α < Fintype.card (Fin (Fintype.card α + 1)) := by simp
  obtain ⟨i, j, hne, heq⟩ := Fintype.exists_ne_map_eq_of_card_lt f hCard
  by_cases hij : (i : ℕ) < j
  · exact ⟨i, j, hij, Nat.lt_succ_iff.mp (Fin.is_lt j), heq⟩
  · push_neg at hij
    have hlt : (j : ℕ) < i := Nat.lt_of_le_of_ne hij (fun h => hne (Fin.ext h.symm))
    exact ⟨j, i, hlt, Nat.lt_succ_iff.mp (Fin.is_lt i), heq.symm⟩

end PigeonholeFintype

-- ═══════════════════════════════════════════════════════════════════════════════
-- 5) Orbit Periodicity
-- ═══════════════════════════════════════════════════════════════════════════════

/-- Key: if orbit repeats at i and j, then it's periodic with period (j-i) from i. -/
theorem orbit_periodic (σ : α → α) (x₀ : α) (i j : ℕ) (hij : i < j)
    (heq : orbit σ x₀ i = orbit σ x₀ j) :
    ∀ n ≥ i, orbit σ x₀ (n + (j - i)) = orbit σ x₀ n := by
  intro n hn
  simp only [orbit]
  have hji : i + (j - i) = j := by omega
  have key : σ^[j] x₀ = σ^[i] x₀ := by simp only [orbit] at heq; exact heq.symm
  calc σ^[n + (j - i)] x₀
      = σ^[n - i + (i + (j - i))] x₀ := by congr 1; omega
    _ = σ^[n - i + j] x₀ := by rw [hji]
    _ = σ^[n - i] (σ^[j] x₀) := by rw [Function.iterate_add_apply]
    _ = σ^[n - i] (σ^[i] x₀) := by rw [key]
    _ = σ^[n - i + i] x₀ := by rw [← Function.iterate_add_apply]
    _ = σ^[n] x₀ := by congr 1; omega

/-- Once orbit repeats at i,j, every value at index n has an equivalent in [0, j-1].
    This follows from periodicity with period (j-i) starting at i. -/
theorem orbit_value_in_initial_segment (σ : α → α) (x₀ : α) (i j : ℕ) (hij : i < j)
    (heq : orbit σ x₀ i = orbit σ x₀ j) (n : ℕ) :
    ∃ m, m < j ∧ orbit σ x₀ n = orbit σ x₀ m := by
  by_cases hn : n < j
  · exact ⟨n, hn, rfl⟩
  · -- n ≥ j, reduce using periodicity
    push_neg at hn
    have hp : j - i > 0 := by omega
    -- m ∈ [i, j-1] such that n ≡ m (mod j-i)
    let m := i + (n - i) % (j - i)
    have hm_lt : m < j := by
      have : (n - i) % (j - i) < j - i := Nat.mod_lt (n - i) hp
      omega
    -- Periodicity: orbit n = orbit m
    -- Technical: n - m = k*(j-i) for k = (n-i)/(j-i), apply orbit_periodic k times
    have heq_nm : orbit σ x₀ n = orbit σ x₀ m := by
      -- Key insight: n = m + k*(j-i) for some k ≥ 0
      -- We prove by strong induction on (n - i)
      have hm_ge_i : m ≥ i := by omega
      have hn_ge_i : n ≥ i := by omega
      -- The distance n - m is a multiple of (j - i)
      have hdiv : (n - i) % (j - i) = (m - i) := by
        simp only [m]
        have : m - i = (n - i) % (j - i) := by omega
        omega
      -- We use that orbit_periodic gives us: orbit (n + (j-i)) = orbit n for n ≥ i
      -- So orbit n = orbit (n - k*(j-i)) for appropriate k
      -- Since n - m = ((n-i) / (j-i)) * (j-i) when (n-i) % (j-i) = m - i
      -- We can reduce n to m by applying periodicity backwards
      have hperiod := orbit_periodic σ x₀ i j hij heq
      -- Prove by showing n and m give same orbit value via periodicity
      -- n = m + q*(j-i) where q = (n - m) / (j - i)
      have hmod_eq : (n - i) % (j - i) = m - i := by omega
      -- Use Nat.div_add_mod: n - i = ((n-i) / (j-i)) * (j-i) + (n-i) % (j-i)
      have hdiv_mod := Nat.div_add_mod (n - i) (j - i)
      -- So n = i + (n-i)/(j-i) * (j-i) + (n-i) % (j-i)
      --      = i + (n-i)/(j-i) * (j-i) + (m - i)
      --      = m + (n-i)/(j-i) * (j-i)
      let q := (n - i) / (j - i)
      have hn_eq : n = m + q * (j - i) := by
        have h1 : n - i = q * (j - i) + (n - i) % (j - i) := by
          rw [mul_comm]; exact hdiv_mod.symm
        have h2 : (n - i) % (j - i) = m - i := hmod_eq
        omega
      -- Now prove by induction on q that orbit (m + q*(j-i)) = orbit m
      suffices h : ∀ k, orbit σ x₀ (m + k * (j - i)) = orbit σ x₀ m by
        rw [hn_eq]; exact h q
      intro k
      induction k with
      | zero => simp
      | succ k' ih =>
        have hm_k' : m + k' * (j - i) ≥ i := by omega
        -- orbit (m + (k'+1)*(j-i)) = orbit (m + k'*(j-i) + (j-i))
        -- by hperiod: orbit (m + k'*(j-i) + (j-i)) = orbit (m + k'*(j-i))
        -- by ih: orbit (m + k'*(j-i)) = orbit m
        have hstep : orbit σ x₀ (m + k' * (j - i) + (j - i)) = orbit σ x₀ (m + k' * (j - i)) :=
          hperiod (m + k' * (j - i)) hm_k'
        show orbit σ x₀ (m + (k' + 1) * (j - i)) = orbit σ x₀ m
        have hArith : m + (k' + 1) * (j - i) = m + k' * (j - i) + (j - i) := by
          simp only [Nat.add_mul, Nat.one_mul, Nat.add_assoc]
        rw [hArith, hstep, ih]
    exact ⟨m, hm_lt, heq_nm⟩

-- ═══════════════════════════════════════════════════════════════════════════════
-- 6) LPO_R1 for Finite Orbit Grammars
-- ═══════════════════════════════════════════════════════════════════════════════

section LPO_Finite

variable [Fintype α]

/-- THE KEY THEOREM: LPO_R1 for finite orbit grammars via pigeonhole. -/
theorem LPO_R1_finite_orbit
    (σ : α → α) (P : α → Prop) [∀ x, Decidable (P x)] :
    ∀ s, OrbitAdm σ s → (∃ n, P (s n)) ∨ (∀ n, ¬ P (s n)) := by
  intro s ⟨x₀, hOrb⟩
  obtain ⟨i, j, hij, hjb, heqij⟩ := orbit_repeats σ x₀
  let bound := Fintype.card α
  cases existsUpTo (fun k => P (s k)) bound with
  | isTrue hEx =>
    left
    exact hEx.elim fun n ⟨_, hPn⟩ => ⟨n, hPn⟩
  | isFalse hNot =>
    right
    intro n
    by_cases hle : n ≤ bound
    · exact fun hPsn => hNot ⟨n, hle, hPsn⟩
    · push_neg at hle
      intro hPsn
      rw [hOrb] at hPsn
      obtain ⟨m, hm, heq⟩ := orbit_value_in_initial_segment σ x₀ i j hij heqij n
      have hmb : m ≤ bound := by omega
      rw [heq] at hPsn
      rw [← hOrb] at hPsn
      exact hNot ⟨m, hmb, hPsn⟩

end LPO_Finite

end RevHalt.OrbitGrammar

-- ═══════════════════════════════════════════════════════════════════════════════
-- Axiom Checks
-- ═══════════════════════════════════════════════════════════════════════════════

#print axioms RevHalt.OrbitGrammar.orbit_not_const
#print axioms RevHalt.OrbitGrammar.existsUpTo
#print axioms RevHalt.OrbitGrammar.orbit_repeats
#print axioms RevHalt.OrbitGrammar.orbit_periodic
#print axioms RevHalt.OrbitGrammar.orbit_value_in_initial_segment
#print axioms RevHalt.OrbitGrammar.LPO_R1_finite_orbit
