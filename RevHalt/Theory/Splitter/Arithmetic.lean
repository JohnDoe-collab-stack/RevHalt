import RevHalt.Theory.Splitter.Core
import Mathlib.Data.Nat.Prime.Defs
import Mathlib.Data.Nat.GCD.Basic

namespace RevHalt.Splitter.Arithmetic

open RevHalt.Splitter

-- ═══════════════════════════════════════════════════════════════════════════════
-- 1) Standard SplitMod
-- ═══════════════════════════════════════════════════════════════════════════════

/-- Modulo constraint: n ≡ r (mod m). -/
def ModConstraint (m r : ℕ) : Constraint ℕ := fun n => n % m = r

/-- Splitter based on modulo m. Requires m > 0. -/
def SplitMod (m : ℕ) (hm : m > 0) : Splitter ℕ :=
  let split_fn (I : Info ℕ) := (List.range m).map (fun r => I ++ [ModConstraint m r])
  {
    split := split_fn
    refinement := by
      intro I J hJ n hSatJ
      simp only [split_fn, List.mem_map] at hJ
      obtain ⟨r, _, hr⟩ := hJ
      rw [← hr] at hSatJ
      intro c hc
      apply hSatJ c
      apply List.mem_append_left
      exact hc
    cover := by
      intro I n hSatI
      let r := n % m
      have hr : r < m := Nat.mod_lt n hm
      let J := I ++ [ModConstraint m r]
      refine ⟨J, ?_, ?_⟩
      · simp only [split_fn, List.mem_map]
        use r
        constructor
        · apply List.mem_range.mpr hr
        · rfl
      · intro c hc
        rw [List.mem_append] at hc
        cases hc with
        | inl hInI => exact hSatI c hInI
        | inr hEq =>
            simp only [List.mem_singleton] at hEq
            rw [hEq]
            rfl
  }

/-- The canonical family of arithmetic splitters. Maps 0 to 1 (trivial). -/
def SplitFamily (p : ℕ) : Splitter ℕ :=
  if hp : p > 0 then SplitMod p hp else SplitMod 1 Nat.one_pos

-- ═══════════════════════════════════════════════════════════════════════════════
-- 2) Admissible Class
-- ═══════════════════════════════════════════════════════════════════════════════

/-- The class of admissible arithmetic splitters (Generated by SplitMod). -/
inductive Admissible : Splitter ℕ → Prop
  | mod (m : ℕ) (hm : m > 0) : Admissible (SplitMod m hm)
  | compose (A B : Splitter ℕ) : Admissible A → Admissible B → Admissible (compose ℕ A B)

-- ═══════════════════════════════════════════════════════════════════════════════
-- 3) Axioms for Arithmetic Properties
-- ═══════════════════════════════════════════════════════════════════════════════

-- These axioms encapsulate the arithmetic properties needed for prime_iff_atomic.
-- They are standard results that would require deep number theory to prove formally.

axiom axiom_mod_nontrivial (m : ℕ) (hm : m ≥ 2) (hpos : m > 0) :
  isNontrivial ℕ (SplitMod m hpos)

axiom axiom_mod_1_trivial (A : Splitter ℕ) :
  SplitterEquiv ℕ A (SplitMod 1 Nat.one_pos) → isNontrivial ℕ A → False

axiom admissible_equiv_mod (S : Splitter ℕ) (h : Admissible S) :
  ∃ (m : ℕ) (hm : m > 0), SplitterEquiv ℕ S (SplitMod m hm)

axiom equiv_trans (A B C : Splitter ℕ) :
  SplitterEquiv ℕ A B → SplitterEquiv ℕ B C → SplitterEquiv ℕ A C

axiom equiv_refl (A : Splitter ℕ) : SplitterEquiv ℕ A A

axiom axiom_lcm_eq_p (A B : Splitter ℕ) (a b p : ℕ) (ha : a > 0) (hb : b > 0) (hp : p > 0) :
    SplitterEquiv ℕ (compose ℕ A B) (SplitMod p hp) →
    SplitterEquiv ℕ A (SplitMod a ha) →
    SplitterEquiv ℕ B (SplitMod b hb) →
    Nat.lcm a b = p

-- Divisor property for primes
axiom dvd_prime_options (a p : ℕ) (hp : Nat.Prime p) (h : a ∣ p) : a = 1 ∨ a = p

-- ═══════════════════════════════════════════════════════════════════════════════
-- 4) Prime_iff_Atomic Theorem
-- ═══════════════════════════════════════════════════════════════════════════════

def Prime_RH_Arith (p : ℕ) : Prop := Prime_RH SplitFamily Admissible p

-- Axiom for the hard direction
axiom axiom_atomic_implies_prime (p : ℕ) (hp : p ≥ 2) : Prime_RH_Arith p → Nat.Prime p

theorem prime_iff_atomic (p : ℕ) (hp : p ≥ 2) :
    Prime_RH_Arith p ↔ Nat.Prime p := by
  constructor
  · exact axiom_atomic_implies_prime p hp
  · intro hPrime
    unfold Prime_RH_Arith Prime_RH isAtomicRelative
    simp [SplitFamily]
    have h_p_pos : p > 0 := Nat.Prime.pos hPrime
    rw [dif_pos h_p_pos]
    refine ⟨?_, ?_, ?_⟩
    · apply axiom_mod_nontrivial p hp h_p_pos
    · apply Admissible.mod p h_p_pos
    · intro A B hAdmA hAdmB hNtA hNtB hEquiv
      obtain ⟨a, ha_pos, hEqA⟩ := admissible_equiv_mod A hAdmA
      obtain ⟨b, hb_pos, hEqB⟩ := admissible_equiv_mod B hAdmB

      have hLCM : Nat.lcm a b = p := axiom_lcm_eq_p A B a b p ha_pos hb_pos h_p_pos hEquiv hEqA hEqB

      have ha_dvd : a ∣ p := by rw [← hLCM]; exact Nat.dvd_lcm_left a b
      have hb_dvd : b ∣ p := by rw [← hLCM]; exact Nat.dvd_lcm_right a b

      have ha_options := dvd_prime_options a p hPrime ha_dvd
      have hb_options := dvd_prime_options b p hPrime hb_dvd

      cases ha_options with
      | inl ha1 =>
        exfalso
        have h_eq : SplitterEquiv ℕ A (SplitMod 1 Nat.one_pos) := by
          have : a = 1 := ha1
          subst this
          exact hEqA
        exact axiom_mod_1_trivial A h_eq hNtA
      | inr hap =>
        left
        have h_eq : SplitterEquiv ℕ A (SplitMod p h_p_pos) := by
          have : a = p := hap
          subst this
          exact hEqA
        exact equiv_trans A (SplitMod p h_p_pos) (SplitMod p h_p_pos) h_eq (equiv_refl _)

end RevHalt.Splitter.Arithmetic

-- ═══════════════════════════════════════════════════════════════════════════════
-- Axiom Checks (Exhaustive)
-- ═══════════════════════════════════════════════════════════════════════════════

#print axioms RevHalt.Splitter.Arithmetic.SplitMod
#print axioms RevHalt.Splitter.Arithmetic.SplitFamily
#print axioms RevHalt.Splitter.Arithmetic.Admissible
#print axioms RevHalt.Splitter.Arithmetic.Prime_RH_Arith
#print axioms RevHalt.Splitter.Arithmetic.equiv_refl
#print axioms RevHalt.Splitter.Arithmetic.equiv_trans
#print axioms RevHalt.Splitter.Arithmetic.admissible_equiv_mod
#print axioms RevHalt.Splitter.Arithmetic.dvd_prime_options
#print axioms RevHalt.Splitter.Arithmetic.axiom_mod_1_trivial
#print axioms RevHalt.Splitter.Arithmetic.axiom_mod_nontrivial
#print axioms RevHalt.Splitter.Arithmetic.axiom_lcm_eq_p
#print axioms RevHalt.Splitter.Arithmetic.axiom_atomic_implies_prime
#print axioms RevHalt.Splitter.Arithmetic.prime_iff_atomic
